
(* A basic version of MLTT with only one Taski-style universe *)

(* Judgment forms *)
sort Ty ()

sort Tm (A : Ty)


(* Taski-style universe *)
constructor U () () : Ty

destructor El () (A : Tm U) () : Ty

(* Dependent products *)
constructor Π   ()
                (A : Ty, B {x : Tm A} : Ty) 
                : Ty

constructor λ   (A : Ty, B {x : Tm A} : Ty) 
                (t {x : Tm A} : Tm B{x}) 
                : Tm Π(A, x. B{x})

destructor ﹫   (A : Ty, B {x : Tm A} : Ty) 
                (t : Tm Π(A, x. B{x}))
                (u : Tm A) 
                : Tm B{u}

rewrite ﹫(λ(x. $t{x}), $u) --> $t{$u}


constructor π () (a : Tm U, b {_ : Tm El(a)} : Tm U) : Tm U

rewrite El(π($a, x.$b{x})) --> Π(El($a), x. El($b{x}))


(* Dependent sums *)
constructor Σ () (A : Ty, B {x : Tm A} : Ty) : Ty

constructor mkΣ     (A : Ty, B {x : Tm A} : Ty) 
                    (t : Tm A, u : Tm B{t}) 
                    : Tm Σ(A, x. B{x})

destructor π₁       (A : Ty, B {x : Tm A} : Ty) 
                    (t : Tm Σ(A, x. B{x}))
                    () : Tm A

destructor π₂       (A : Ty, B {x : Tm A} : Ty) 
                    (t : Tm Σ(A, x. B{x}))
                    () : Tm B{π₁(t)}

rewrite π₁(mkΣ($t, $u)) --> $t

rewrite π₂(mkΣ($t, $u)) --> $u


constructor σ () (a : Tm U, b {x : Tm El(a)} : Tm U) : Tm U

rewrite El(σ($a, x.$b{x})) --> Σ(El($a), x. El($b{x}))


(* axiom of choice *)
let ac : Tm Π(U, a. Π(U, b. Π(Π(El(b), _. U), c.
            Π(Π(El(a), _. Σ(El(b), x. El(﹫(c, x)))), _.
            Σ(Π(El(a), _. El(b)), f. Π(El(a), x. El(﹫(c, ﹫(f, x)))))))))
    := λ(a. λ(b. λ(c. λ(ϕ. mkΣ(λ(x. π₁(﹫(ϕ, x))), λ(x. π₂(﹫(ϕ, x))))))))
type ac

(* Natural numbers *)

constructor ℕ () () : Ty
constructor 0 () () : Tm ℕ
constructor S () (_ : Tm ℕ) : Tm ℕ

destructor ℕ_ind    ()
                    (n : Tm ℕ)
                    (P {x : Tm ℕ} : Ty, 
                     p0 : Tm P{0}, 
                     ps {n : Tm ℕ, pn : Tm P{n}} : Tm P{S(n)})
                (* ------------ *)
                    : Tm P(n)

rewrite ℕ_ind(0, x. $P{x}, $p0, n pn. $ps{n, pn}) --> $p0
rewrite ℕ_ind(S($n), x. $P{x}, $p0, n pn. $ps{n, pn}) -->
    $ps{$n, ℕ_ind($n, x. $P{x}, $p0, n pn. $ps{n, pn})}

(* code in U for ℕ *)
constructor nat () () : Tm U

rewrite El(nat) --> ℕ

(* Some functions written using ℕ_ind *)

let ＋ : Tm Π(ℕ, _. Π(ℕ, _. ℕ)) := λ(x. λ(y. ℕ_ind(y, _. ℕ, x, _ n. S(n))))

let × : Tm Π(ℕ, _. Π(ℕ, _. ℕ)) :=
    λ(x. λ(y. ℕ_ind(y, _. ℕ, 0, _ n. ﹫(﹫(＋, n), x))))

let fact : Tm Π(ℕ, _. ℕ) := λ(x. ℕ_ind(x, _. ℕ, S(0), n m. ﹫(﹫(×, S(n)), m)))

let fact_4 := ﹫(fact, S(S(S(S(0)))))
eval fact_4



(* Lists *)

constructor List () (A : Ty) : Ty
constructor nil (A : Ty) () : Tm List(A)
constructor cons (A : Ty) (a : Tm A, l : Tm List(A)) : Tm List(A)

destructor ind_List     (A : Ty)
                        (l : Tm List(A))
                        (P {x : Tm List(A)} : Ty,
                         l_nil : Tm P{nil},
                         l_cons {a : Tm A, l : Tm List(A), pl : Tm P{l}} : Tm P{cons(a, l)})
                        (* -------------- *)
                        : Tm P{l}

rewrite ind_List(nil, l. $P{l}, $p_nil, a l pl. $p_cons{a, l, pl}) --> $p_nil
rewrite ind_List(cons($a, $l), l. $P{l}, $p_nil, a l pl. $p_cons{a, l, pl}) -->
    $p_cons($a, $l, ind_List($l, l. $P{l}, $p_nil, a l pl. $p_cons{a, l, pl}))


(* code in U for List *)
constructor list () (a : Tm U) : Tm U
rewrite El(list($a)) --> List(El($a))


let 0∷1∷2∷3∷nil : Tm List(ℕ) := cons(0, cons(S(0), cons(S(S(0)), cons(S(S(S(0))), nil))))

let sum_of_list : Tm Π(List(ℕ), _. ℕ) :=
    λ(l. ind_List(l, _. ℕ, 0, x _ acc. ﹫(﹫(＋, x), acc)))

eval ﹫(sum_of_list, 0∷1∷2∷3∷nil)
