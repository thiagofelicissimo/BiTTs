
(* A basic version of MLTT with only one Taski-style universe *)

(* Judgment forms *)
symbol Ty : *

symbol Tm (A : Ty) : *


(* Taski-style universe *)
symbol U : Ty

symbol El (A : Tm U) : Ty



(* Dependent products *)
symbol+ Π (A : Ty)- (B : (x : Tm A) Ty)- : Ty

symbol- λ {A : Ty} {B : (_ : Tm A) Ty} (t : (x : Tm A) Tm B(x))- : Tm Π(A, x. B(x))

symbol+ ﹫ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Π(A, x. B(x)))+ (u : Tm A)- : Tm B(u)

rew ﹫(λ(x. $t(x)), $u) --> $t($u)


symbol π (a : Tm U) (b : (_ : Tm El(a)) Tm U) : Tm U

rew El(π($a, x.$b(x))) --> Π(El($a), x. El($b(x)))


(* Dependent sums *)
symbol Σ (A : Ty) (B : (x : Tm A) Ty) : Ty

symbol- mkΣ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm A) (u : Tm B(t)) : Tm Σ(A, x. B(x))

symbol π₁ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Σ(A, x. B(x)))+ : Tm A

symbol π₂ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Σ(A, x. B(x)))+ : Tm B(π₁(t))

rew π₁(mkΣ($t, $u)) --> $t

rew π₂(mkΣ($t, $u)) --> $u


symbol σ (a : Tm U) (b : (_ : Tm El(a)) Tm U) : Tm U

rew El(σ($a, x.$b(x))) --> Σ(El($a), x. El($b(x)))


(* axiom of choice *)
let ac : Tm Π(U, a. Π(U, b. Π(Π(El(b), _. U), c.
            Π(Π(El(a), _. Σ(El(b), x. El(﹫(c, x)))), _.
            Σ(Π(El(a), _. El(b)), f. Π(El(a), x. El(﹫(c, ﹫(f, x)))))))))
    := λ(a. λ(b. λ(c. λ(ϕ. mkΣ(λ(x. π₁(﹫(ϕ, x))), λ(x. π₂(﹫(ϕ, x))))))))
type ac


(* Equality type *)
symbol Eq (A : Ty) (t : Tm A) (u : Tm A) : Ty

symbol- refl {A : Ty} {t : Tm A} : Tm Eq(A, t, t)

symbol J {A : Ty} {a : Tm A} {b : Tm A} (t : Tm Eq(A, a, b))+
       (P : (x : Tm A, y : Tm Eq(A, a, x)) Ty) (prefl : Tm P(a, refl)) : Tm P(b, t)

rew J(refl, x y. $P(x, y), $prefl) --> $prefl

(* code in U for Eq *)
symbol eq (a : Tm U) (x : Tm El(a)) (y : Tm El(a)) : Tm U

rew El(eq($a, $x, $y)) --> Eq(El($a), $x, $y)


(* Proofs of symmetry, transitivity and transport. *)

let sym : Tm Π(U, a. Π(El(a), x. Π(El(a), y. Π(Eq(El(a), x, y), _. Eq(El(a), y, x)))))
    :=  λ(a. λ(x. λ(y. λ(p. J(p, z q. Eq(El(a), z, x), refl)))))

let trans : Tm Π(U, a. Π(El(a), x. Π(El(a), y. Π(El(a), z.
               Π(Eq(El(a), x, y), _. Π(Eq(El(a), y, z), _. Eq(El(a), x, z)))))))
    := λ(a. λ(x. λ(y. λ(z. λ(p. λ(q. J(q, k r. Eq(El(a), x, k), p)))))))

let transp : Tm Π(U, a. Π(U, b. Π(Eq(U, a, b), _. Π(El(a), _. El(b)))))
    := λ(a. λ(b. λ(p. λ(x. J(p, z q. El(z), x)))))


(* Natural numbers *)

symbol ℕ : Ty
symbol 0 : Tm ℕ
symbol S (_ : Tm ℕ) : Tm ℕ

symbol+ ℕ_ind (P : (_ : Tm ℕ) Ty)
              (p0 : Tm P(0))
              (ps : (n : Tm ℕ, pn : Tm P(n)) Tm P(S(n)))
              (n : Tm ℕ)
              (* ------------ *)
              : Tm P(n)

rew ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), 0) --> $p0
rew ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), S($n)) -->
    $ps($n, ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), $n))

(* code in U for ℕ *)
symbol nat : Tm U

rew El(nat) --> ℕ

(* Some functions written using ℕ_ind *)

let ＋ : Tm Π(ℕ, _. Π(ℕ, _. ℕ)) := λ(x. λ(y. ℕ_ind(_. ℕ, x, _ n. S(n), y)))

let × : Tm Π(ℕ, _. Π(ℕ, _. ℕ)) :=
    λ(x. λ(y. ℕ_ind(_. ℕ, 0, _ n. ﹫(﹫(＋, n), x), y)))

let fact : Tm Π(ℕ, _. ℕ) := λ(x. ℕ_ind(_. ℕ, S(0), n m. ﹫(﹫(×, S(n)), m), x))

let fact_4 := ﹫(fact, S(S(S(S(0)))))
eval fact_4



(* Lists *)

symbol List (A : Ty) : Ty
symbol- nil {A : Ty} : Tm List(A)
symbol- cons {A : Ty} (a : Tm A) (l : Tm List(A)) : Tm List(A)

symbol ind_List {A : Ty}
              (l : Tm List(A))+
              (P : (_ : Tm List(A)) Ty)
              (l_nil : Tm P(nil))
              (l_cons : (a : Tm A, l : Tm List(A), pl : Tm P(l)) Tm P(cons(a, l)))
              (* -------------- *)
              : Tm P(l)

rew ind_List(nil, l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)) --> $p_nil
rew ind_List(cons($a, $l), l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)) -->
    $p_cons($a, $l, ind_List($l, l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)))


(* code in U for List *)
symbol list (a : Tm U) : Tm U
rew El(list($a)) --> List(El($a))


let 0∷1∷2∷3∷nil : Tm List(ℕ) := cons(0, cons(S(0), cons(S(S(0)), cons(S(S(S(0))), nil))))

let sum_of_list : Tm Π(List(ℕ), _. ℕ) :=
    λ(l. ind_List(l, _. ℕ, 0, x _ acc. ﹫(﹫(＋, x), acc)))

eval ﹫(sum_of_list, 0∷1∷2∷3∷nil)
