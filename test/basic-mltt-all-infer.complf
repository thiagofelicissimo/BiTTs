
(* A basic version of MLTT with only one Tarski-style universe, in which all constants
   are inferable (like in Coq), and therefore for which our bidirectional typing
   algorithm is complete also for terms not in normal form *)

(* Judgment forms *)
symbol Ty : *

symbol Tm (A : Ty) : *


(* Taski-style universe *)
symbol U : Ty

symbol El (A : Tm U) : Ty


(* Dependent products *)
symbol Π (A : Ty) (B : (x : Tm A) Ty) : Ty

symbol λ (A : Ty) {B : (_ : Tm A) Ty} (t : (x : Tm A) Tm B(x))+ : Tm Π(A, x. B(x))

symbol ﹫ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Π(A, x. B(x)))+ (u : Tm A) : Tm B(u)

rew ﹫(λ($A, x. $t(x)), $u) --> $t($u)

(* codes for dep products *)
symbol π (a : Tm U) (b : (_ : Tm El(a)) Tm U) : Tm U

rew El(π($a, x.$b(x))) --> Π(El($a), x. El($b(x)))


(* a test to show we can type redexes *)
type λ(U, a. ﹫(λ(U, b. b), a))


(* Dependent sums *)
symbol Σ (A : Ty) (B : (x : Tm A) Ty) : Ty

symbol mkΣ {A : Ty} (t : Tm A)+ (B : (_ : Tm A) Ty) (u : Tm B(t)) : Tm Σ(A, x. B(x))

symbol π₁ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Σ(A, x. B(x)))+ : Tm A

symbol π₂ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Σ(A, x. B(x)))+ : Tm B(π₁(t))

rew π₁(mkΣ($t, x. $B(x), $u)) --> $t

rew π₂(mkΣ($t, x. $B(x), $u)) --> $u


(* codes for dep sums *)
symbol σ (a : Tm U) (b : (_ : Tm El(a)) Tm U) : Tm U

rew El(σ($a, x.$b(x))) --> Σ(El($a), x. El($b(x)))


(* axiom of choice *)
(* because all constants are inferable, there is no need for giving the type annotation of ac *)
let ac := λ(U, a. λ(U, b. λ(Π(El(b), _. U), c.
          λ(Π(El(a), _. Σ(El(b), x. El(﹫(c, x)))), ϕ.
          mkΣ(λ(El(a), x. π₁(﹫(ϕ, x))),
              f. Π(El(a), x. El(﹫(c, ﹫(f, x)))),
              λ(El(a), x. π₂(﹫(ϕ, x))))))))
type ac


(* Equality type *)
symbol Eq (A : Ty) (t : Tm A) (u : Tm A) : Ty

symbol refl {A : Ty} (t : Tm A)+ : Tm Eq(A, t, t)

symbol J {A : Ty} {a : Tm A} {b : Tm A} (t : Tm Eq(A, a, b))+
       (P : (x : Tm A, y : Tm Eq(A, a, x)) Ty) (prefl : Tm P(a, refl(a))) : Tm P(b, t)

rew J(refl($a), x y. $P(x, y), $prefl) --> $prefl

(* code in U for Eq *)
symbol eq (a : Tm U) (x : Tm El(a)) (y : Tm El(a)) : Tm U
rew El(eq($a, $x, $y)) --> Eq(El($a), $x, $y)

(* proofs of symmetry, transitivity and transport. once again, no need to annotate
   them with their types, as these can be inferred, so we leave them as comments *)

let sym (* : Tm Π(U, a. Π(El(a), x. Π(El(a), y. Π(Eq(El(a), x, y), _. Eq(El(a), y, x))))) *)
    := λ(U, a. λ(El(a), x. λ(El(a), y. λ(Eq(El(a), x, y), p. J(p, z q. Eq(El(a), z, x), refl(x))))))
type sym

let trans (* : Tm Π(U, a. Π(El(a), x. Π(El(a), y. Π(El(a), z.
                  Π(Eq(El(a), x, y), _. Π(Eq(El(a), y, z), _. Eq(El(a), x, z))))))) *)
    := λ(U, a. λ(El(a), x. λ(El(a), y. λ(El(a), z.
       λ(Eq(El(a), x, y), p. λ(Eq(El(a), y, z), q. J(q, k r. Eq(El(a), x, k), p)))))))
type trans

let transp (* : Tm Π(U, a. Π(U, b. Π(Eq(U, a, b), _. Π(El(a), _. El(b))))) *)
    := λ(U, a. λ(U, b. λ(Eq(U, a, b), p. λ(El(a), x. J(p, z q. El(z), x)))))
type transp


(* Natural numbers *)

symbol ℕ : Ty
symbol 0 : Tm ℕ
symbol S (_ : Tm ℕ) : Tm ℕ

symbol+ ℕ_ind (P : (_ : Tm ℕ) Ty)
              (p0 : Tm P(0))
              (ps : (n : Tm ℕ, pn : Tm P(n)) Tm P(S(n)))
              (n : Tm ℕ)
              (* ------------ *)
              : Tm P(n)

rew ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), 0) --> $p0
rew ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), S($n)) -->
    $ps($n, ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), $n))

(* code in U for ℕ *)
symbol nat : Tm U
rew El(nat) --> ℕ

(* Some functions written using ℕ_ind *)

let ＋   (* : Tm Π(ℕ, _. Π(ℕ, _. ℕ)) *)
    := λ(ℕ, x. λ(ℕ, y. ℕ_ind(_. ℕ, x, _ n. S(n), y)))

let ×    (* : Tm Π(ℕ, _. Π(ℕ, _. ℕ)) *)
    := λ(ℕ, x. λ(ℕ, y. ℕ_ind(_. ℕ, 0, _ n. ﹫(﹫(＋, n), x), y)))

let fact   (* : Tm Π(ℕ, _. ℕ) *)
    := λ(ℕ, x. ℕ_ind(_. ℕ, S(0), n m. ﹫(﹫(×, S(n)), m), x))

let fact_4 := ﹫(fact, S(S(S(S(0)))))
eval fact_4

(* Lists *)

symbol List (A : Ty) : Ty
symbol nil (A : Ty) : Tm List(A)
symbol cons {A : Ty} (a : Tm A)+ (l : Tm List(A)) : Tm List(A)

symbol ind_List {A : Ty}
              (l : Tm List(A))+
              (P : (_ : Tm List(A)) Ty)
              (l_nil : Tm P(nil(A)))
              (l_cons : (a : Tm A, l : Tm List(A), pl : Tm P(l)) Tm P(cons(a, l)))
              (* -------------- *)
              : Tm P(l)

rew ind_List(nil($A), l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)) --> $p_nil
rew ind_List(cons($a, $l), l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)) -->
    $p_cons($a, $l, ind_List($l, l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)))


(* code in U for List *)
symbol list (a : Tm U) : Tm U
rew El(list($a)) --> List(El($a))


let 0∷1∷2∷3∷nil := cons(0, cons(S(0), cons(S(S(0)), cons(S(S(S(0))), nil(ℕ)))))

let sum_of_list :=
    λ(List(ℕ), l. ind_List(l, _. ℕ, 0, x _ acc. ﹫(﹫(＋, x), acc)))

eval ﹫(sum_of_list, 0∷1∷2∷3∷nil)
