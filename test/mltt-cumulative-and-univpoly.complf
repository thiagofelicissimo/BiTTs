
(* MLTT with cumulative Tarski-style universes and universe polymorphism *)


(* Standard MLTT judgment forms *)
symbol Ty : *

symbol Tm (A : Ty) : *


(* Univ levels *)
symbol Lvl : *       (* a new judgment form *)

symbol lzero : Lvl

symbol lsucc (_ : Lvl) : Lvl


(* Universes *)
symbol U (_ : Lvl) : Ty

symbol El {i : Lvl} (A : Tm U(i))+ : Ty

symbol u (i : Lvl) : Tm U(lsucc(i))

rew El(u($i)) --> U($i)


(* Lift for cumulativity *)
symbol ↑ {i : Lvl} (A : Tm U(i))+ : Tm U(lsucc(i))

rew El(↑($a)) --> El($a)


(* Level quantification (universe polymorphism) *)
symbol ∀ (_ : (i : Lvl) Ty) : Ty

symbol- Λ {A : (i : Lvl) Ty} (t : (i : Lvl) Tm A(i)) : Tm ∀(i. A(i))

symbol inst {A : (i : Lvl) Ty} (t : Tm ∀(i. A(i)))+ (n : Lvl) : Tm A(n)

rew inst(Λ(i. $t(i)), $n) --> $t($n)


(* Dependent products *)
symbol Π (A : Ty) (B : (x : Tm A) Ty) : Ty

symbol- λ {A : Ty} {B : (_ : Tm A) Ty} (t : (x : Tm A) Tm B(x)) : Tm Π(A, x. B(x))

symbol ﹫ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Π(A, x. B(x)))+ (u : Tm A) : Tm B(u)

rew ﹫(λ(x. $t(x)), $u) --> $t($u)


symbol π {i : Lvl} (a : Tm U(i))+ (b : (_ : Tm El(a)) Tm U(i)) : Tm U(i)

rew El(π($a, x.$b(x))) --> Π(El($a), x. El($b(x)))

rew ↑(π($a, x.$b(x))) --> π(↑($a), x.↑($b(x)))


(* polymorphic id *)
let id_poly : Tm ∀(i. El(π(u(i), a. ↑(π(a, _. a)))))
    := Λ(i. λ(a. λ(x. x)))

type id_poly


(* Dependent sums *)
symbol Σ (A : Ty) (B : (x : Tm A) Ty) : Ty

symbol- mkΣ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm A) (u : Tm B(t)) : Tm Σ(A, x. B(x))

symbol π₁ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Σ(A, x. B(x)))+ : Tm A

symbol π₂ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Σ(A, x. B(x)))+ : Tm B(π₁(t))

rew π₁(mkΣ($t, $u)) --> $t

rew π₂(mkΣ($t, $u)) --> $u


symbol σ {i : Lvl} (a : Tm U(i))+ (b : (_ : Tm El(a)) Tm U(i)) : Tm U(i)

rew El(σ($a, x.$b(x))) --> Σ(El($a), x. El($b(x)))

rew ↑(σ($a, x.$b(x))) --> σ(↑($a), x.↑($b(x)))


(* axiom of choice *)
let ac : Tm ∀(i. El(π(u(i), a. π(u(i), b. π(π(↑(b), _. u(i)), c.
                  ↑(π(π(a, _. σ(b, x. ﹫(c, x))), _.
                    σ(π(a, _. b), f. π(a, x. ﹫(c, ﹫(f, x)))))))))))
    := Λ(i. λ(a. λ(b. λ(c. λ(ϕ. mkΣ(λ(x. π₁(﹫(ϕ, x))), λ(x. π₂(﹫(ϕ, x)))))))))

type ac (* gives its normalized type:
     ∀(i.
       Π(U(i), a. Π(U(i), b. Π(Π(El(b), _. U(i)), c.
       Π(Π(El(a), _. Σ(El(b), x. El(﹫(c, x)))), _.
       Σ(Π(El(a), _. El(b)), f. Π(El(a), x. El(﹫(c, ﹫(f, x)))))))))) *)


(* Equality type *)
symbol Eq (A : Ty) (t : Tm A) (u : Tm A) : Ty

symbol- refl {A : Ty} {t : Tm A} : Tm Eq(A, t, t)

symbol J {A : Ty} {a : Tm A} {b : Tm A} (t : Tm Eq(A, a, b))+
       (P : (x : Tm A, y : Tm Eq(A, a, x)) Ty) (prefl : Tm P(a, refl)) : Tm P(b, t)

rew J(refl, x y. $P(x, y), $prefl) --> $prefl


(* code in U for Eq *)
symbol eq {i : Lvl} (a : Tm U(i))+ (x : Tm El(a)) (y : Tm El(a)) : Tm U(i)

rew El(eq($a, $x, $y)) --> Eq(El($a), $x, $y)

rew ↑(eq($a, $t, $u)) --> eq(↑($a), $t, $u)


(* transport *)
let transp : Tm ∀(i. El(π(u(i), a. π(u(i), b. π(eq(u(i), a, b), _. ↑(π(a, _. b)))))))
    := Λ(i. λ(a. λ(b. λ(p. λ(x. J(p, z q. El(z), x))))))

(* gives Tm Π(U(lzero), a. Π(U(lzero), b. Π(Eq(U(lzero), a, b), _. Π(El(a), _. El(b))))) *)
type inst(transp, lzero)
