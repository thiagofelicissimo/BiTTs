
(* A theory combining a pure type theory with an exceptional one,
   inspired by Maillard et al's Multiverse Type Theory (MuTT). *)

(* Modes *)
sort ð” ()
constructor ð“” () () : ð” (* exceptional *)
constructor ð“Ÿ () () : ð” (* pure *)

(* Judgment forms *)
sort Ty (m : ð”)
sort Tm (m : ð”, A : Ty(m))

sort Ex ()
constructor err () () : Ex
constructor raise (A : Ty(ð“”)) (e : Ex) : Tm(ð“”, A)
constructor raiseTy () (e : Ex) : Ty(ð“”)


(* â–¡ injects the exceptional world into the pure world:
   Tm(ð“Ÿ, â–¡(A)) = Tm(ð“”, A) *)
constructor â–¡ () (A : Ty(ð“”)) : Ty(ð“Ÿ)
equation Tm(ð“Ÿ, â–¡(A)) --> Tm(ð“”, A)

(* note that adding a symmetric operator going in the
   other direction would render all types in ð“Ÿ inhabited *)


(* Taski-style universe *)
constructor U (m : ð”) () : Ty(m)
destructor El (m : ð”) [A : Tm(m, U)] () : Ty(m)

equation El(raise(e)) --> raiseTy(e)

(* Dependent products *)
constructor Î    (m : ð”)
                (A : Ty(m), B{x : Tm(m, A)} : Ty(m))
                : Ty(m)

constructor Î»   (m : ð”, A : Ty(m), B{x : Tm(m, A)} : Ty(m))
                (t{x : Tm(m, A)} : Tm(m, B{x}))
                : Tm(m, Î (A, x. B{x}))

destructor ï¹«   (m : ð”, A : Ty(m), B{x : Tm(m, A)} : Ty(m))
                [t : Tm(m, Î (A, x. B{x}))]
                (u : Tm(m, A))
                : Tm(m, B{u})

equation ï¹«(Î»(x. t{x}), u) --> t{u}

equation ï¹«(raise(e), u) --> raise(e)

(* code in U for Î  *)
constructor Ï€ (m : ð”) (a : Tm(m, U), b{_ : Tm(m, El(a))} : Tm(m, U)) : Tm(m, U)
equation El(Ï€(a, x.b{x})) --> Î (El(a), x. El(b{x}))

(* booleans *)
constructor Bool (m : ð”) () : Ty(m)
constructor tt (m : ð”) () : Tm(m, Bool)
constructor ff (m : ð”) () : Tm(m, Bool)

(* we have three eliminators:
  - ifð“Ÿ for going from ð“Ÿ to any
  - ifð“” for going from ð“” to ð“”
  - catchBool for going from ð“” to any *)

destructor ifð“Ÿ () [x : Tm(ð“Ÿ, Bool)]
                  (m : ð”,
                   P{x : Tm(ð“Ÿ, Bool)} : Ty(m),
                   a : Tm(m, P{tt}),
                   b : Tm(m, P{ff})) : Tm(m, P{x})

equation ifð“Ÿ(tt, m, x.P{x}, a, b) --> a
equation ifð“Ÿ(ff, m, x.P{x}, a, b) --> b


destructor ifð“” () [x : Tm(ð“”, Bool)]
                  (P{x : Tm(ð“”, Bool)} : Ty(ð“”),
                   a : Tm(ð“”, P{tt}),
                   b : Tm(ð“”, P{ff})) : Tm(ð“”, P{x})

equation ifð“”(tt, x.P{x}, a, b) --> a
equation ifð“”(ff, x.P{x}, a, b) --> b
equation ifð“”(raise(e), x.P{x}, a, b) --> raise(e)


destructor catchBool () [x : Tm(ð“”, Bool)]
                     (m : ð”,
                      P{x : Tm(ð“”, Bool)} : Ty(m),
                      a : Tm(m, P{tt}),
                      b : Tm(m, P{ff}),
                      perr{e : Ex} : Tm(m, P{raise(e)}))
                      : Tm(m, P{x})

equation catchBool(tt, m, x.P{x}, a, b, e. perr{e}) --> a
equation catchBool(ff, m, x.P{x}, a, b, e. perr{e}) --> b
equation catchBool(raise(e), m, x.P{x}, a, b, e. perr{e}) --> perr{e}


constructor bool (m : ð”) () : Tm(m, U)
equation El(bool) --> Bool