
(* A theory inspired by Maillard et al's Multiverse Type Theory (MuTT),
   with a pure and an exceptional mode *)

(* Modes *)
sort ð” ()
constructor ð“” () () : ð” (* exceptional *)
constructor ð“Ÿ () () : ð” (* pure *)

(* Judgment forms *)
sort Ty (m : ð”)
sort Tm (m : ð”, A : Ty(m))

sort Ex ()
constructor err () () : Ex
constructor raise (A : Ty(ð“”)) (e : Ex) : Tm(ð“”, A)
constructor raiseTy () (e : Ex) : Ty(ð“”)


(* â–¡ injects the exceptional world into the pure world:
   Tm(ð“”, A) is a retract of Tm(ð“Ÿ, â–¡(A)) *)
constructor â–¡ () (A : Ty(ð“”)) : Ty(ð“Ÿ)
constructor box (A : Ty(ð“”)) (t : Tm(ð“”, A)) : Tm(ð“Ÿ, â–¡(A))
destructor unbox (A : Ty(ð“”)) [t : Tm(ð“Ÿ, â–¡(A))] () : Tm(ð“”, A)
equation unbox(box(t)) --> t

(* note that adding a symmetric operator going in the
   other direction would render all types in ð“Ÿ inhabited *)


(* Taski-style universe *)
constructor U (m : ð”) () : Ty(m)
destructor El (m : ð”) [A : Tm(m, U)] () : Ty(m)

equation skipcheck El(raise(e)) --> raiseTy(e)

(* Dependent products *)
constructor Î    (m : ð”)
                (A : Ty(m), B{x : Tm(m, A)} : Ty(m))
                : Ty(m)

constructor Î»   (m : ð”, A : Ty(m), B{x : Tm(m, A)} : Ty(m))
                (t{x : Tm(m, A)} : Tm(m, B{x}))
                : Tm(m, Î (A, x. B{x}))

destructor ï¹«   (m : ð”, A : Ty(m), B{x : Tm(m, A)} : Ty(m))
                [t : Tm(m, Î (A, x. B{x}))]
                (u : Tm(m, A))
                : Tm(m, B{u})

equation ï¹«(Î»(x. t{x}), u) --> t{u}

(* code in U for Î  *)
constructor Ï€ (m : ð”) (a : Tm(m, U), b{_ : Tm(m, El(a))} : Tm(m, U)) : Tm(m, U)
equation El(Ï€(a, x.b{x})) --> Î (El(a), x. El(b{x}))

(* booleans *)
constructor Bool (m : ð”) () : Ty(m)
constructor tt (m : ð”) () : Tm(m, Bool)
constructor ff (m : ð”) () : Tm(m, Bool)

(* we have three eliminators:
  - ifð“Ÿ for going from ð“Ÿ to any
  - ifð“” for going from ð“” to ð“”
  - catchBool for going from ð“” to any *)

destructor ifð“Ÿ () [x : Tm(ð“Ÿ, Bool)]
                  (m : ð”,
                   P{x : Tm(ð“Ÿ, Bool)} : Ty(m),
                   a : Tm(m, P{tt}),
                   b : Tm(m, P{ff})) : Tm(m, P{x})

equation skipcheck ifð“Ÿ(tt, m, x.P{x}, a, b) --> a
equation skipcheck ifð“Ÿ(ff, m, x.P{x}, a, b) --> b


destructor ifð“” () [x : Tm(ð“”, Bool)]
                  (P{x : Tm(ð“”, Bool)} : Ty(ð“”),
                   a : Tm(ð“”, P{tt}),
                   b : Tm(ð“”, P{ff})) : Tm(ð“”, P{x})

equation skipcheck ifð“”(tt, x.P{x}, a, b) --> a
equation skipcheck ifð“”(ff, x.P{x}, a, b) --> b
equation skipcheck ifð“”(raise(e), x.P{x}, a, b) --> raise(e)


destructor catchBool () [x : Tm(ð“”, Bool)]
                     (m : ð”,
                      P{x : Tm(ð“”, Bool)} : Ty(m),
                      a : Tm(m, P{tt}),
                      b : Tm(m, P{ff}),
                      perr{e : Ex} : Tm(m, P{raise(e)}))
                      : Tm(m, P{x})

equation skipcheck catchBool(tt, m, x.P{x}, a, b, e. perr{e}) --> a
equation skipcheck catchBool(ff, m, x.P{x}, a, b, e. perr{e}) --> b
equation skipcheck catchBool(raise(e), m, x.P{x}, a, b, e. perr{e}) --> perr{e}


constructor bool (m : ð”) () : Tm(m, U)
equation El(bool) --> Bool