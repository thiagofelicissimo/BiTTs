
(* MLTT with a hierarchy of cumulative Russell-style universes, and universe polymorphism *)

sort Lvl ()
constructor 0ₗ () () : Lvl
constructor Sₗ () (_ : Lvl) : Lvl

sort Ty (l : Lvl)
sort Tm (l : Lvl, A : Ty(l))


(* Russell-style Universes *)
constructor U (l : Lvl) () : Ty(Sₗ(l))
rewrite Tm(Sₗ(l), U) --> Ty(l)

(* Strict Cumulativity *)
constructor ↑ (l : Lvl) (A : Ty(l)) : Ty(Sₗ(l))
rewrite Tm(Sₗ(l), ↑(A)) --> Tm(l, A)

(* Dependent products *)
constructor Π (l : Lvl) (A : Ty(l), B {x : Tm(l, A)} : Ty(l)) : Ty(l)
constructor λ (l : Lvl,  A : Ty(l), B {x : Tm(l, A)} : Ty(l)) (t{x : Tm(l, A)} : Tm(l, B{x}))
        : Tm(l, Π(A, x. B{x}))
destructor ﹫ (l : Lvl,  A : Ty(l), B {x : Tm(l, A)} : Ty(l)) [t : Tm (l, Π(A, x. B{x}))] (u : Tm(l, A))
        : Tm(l, B{u})

rewrite ﹫(λ(x. t{x}), u) --> t{u}

(* we unfortunately cannot add the equation ↑(Π(A, x.B{x})) --> Π(↑(A),x.↑(B{x})).
   if we orient it in the direct sense, then this creates an unjoinable critical
   pair with the rule Tm(Sₗ(l), ↑(A)) --> Tm(l, A)
   if we orient it in the inverse sense, then the pattern Tm(l, Π(A, x. B{x}))
   in λ and ﹫ would overlap it *)

(* Natural numbers *)
constructor ℕ () () : Ty(0ₗ)
constructor 0 () () : Tm(0ₗ, ℕ)
constructor S () (_ : Tm(0ₗ, ℕ)) : Tm(0ₗ, ℕ)

destructor ℕ_ind    ()
                    [n : Tm(0ₗ, ℕ)]
                    (i : Lvl,
                     P {x : Tm(0ₗ, ℕ)} : Ty(i),
                     p0 : Tm(i, P{0}),
                     ps {n : Tm(0ₗ, ℕ), pn : Tm(i, P{n})} : Tm(i, P{S(n)}))
                (* ------------ *)
                    : Tm(i, P{n})

rewrite ℕ_ind(0, i, x. P{x}, p0, n pn. ps{n, pn}) --> p0
rewrite ℕ_ind(S(n), i, x. P{x}, p0, n pn. ps{n, pn}) -->
    ps{n, ℕ_ind(n, i, x. P{x}, p0, n pn. ps{n, pn})}


(* top universe *)
sort Tyω ()
sort Tmω (A : Tyω)

(* puts a type in Tmω *)
constructor ↑ω () (l : Lvl, A : Ty(l)) : Tyω
rewrite Tmω(↑ω(l, A)) --> Tm(l, A)

(* universe polymorphism (quantification over levels) *)
constructor ∀ () (A {i : Lvl} : Tyω) : Tyω
constructor Λ (A {i : Lvl} : Tyω) (t{i : Lvl} : Tmω(A{i}))
        : Tmω(∀(i. A{i}))
destructor inst (A {i : Lvl} : Tyω) [t : Tmω(∀(i. A{i}))] (l : Lvl)
        : Tmω(A{l})
rewrite inst(Λ(i. t{i}), l) --> t{l}


(* universe polymorphic id function *)
let id_poly : Tmω(∀(i. ↑ω(Sₗ(i), Π(U, A. Π(↑(A), _. ↑(A))))))
    :=  Λ(i. λ(A. λ(x. x)))

(* applying it to 0 *)
let 0' : Tm(0ₗ, ℕ) := ﹫(﹫(inst(id_poly, 0ₗ), ℕ), 0)
check 0' = 0
