
(* Heterogeneous OTT with a Taski-style universe *)

(* Judgment forms *)
sort Ty ()
sort Tm (A : Ty)

(* Taski-style universe *)
constructor U () () : Ty
destructor El () [A : Tm(U)] () : Ty

(* Dependent products *)
constructor Î    ()
                (A : Ty, B{x : Tm(A)} : Ty)
                : Ty

constructor Î»   (A : Ty, B{x : Tm(A)} : Ty)
                (t{x : Tm(A)} : Tm(B{x}))
                : Tm(Î (A, x. B{x}))

destructor ï¹«   (A : Ty, B{x : Tm(A)} : Ty)
                [t : Tm(Î (A, x. B{x}))]
                (u : Tm(A))
                : Tm(B{u})

equation ï¹«(Î»(x. t{x}), u) --> t{u}

constructor Ï€ () (a : Tm(U), b{_ : Tm(El(a))} : Tm(U)) : Tm(U)
equation El(Ï€(a, x.b{x})) --> Î (El(a), x. El(b{x}))


(* W Types *)
constructor W () (A : Ty, B{x : Tm(A)} : Ty) : Ty
constructor sup (A : Ty, B{x : Tm(A)} : Ty)
                (a : Tm(A), f : Tm(Î (B{a}, _. W(A, x.B{x}))))
                : Tm(W(A, x.B{x}))

destructor Wind     (A : Ty, B{x : Tm(A)} : Ty)
                    [t : Tm(W(A, x.B{x}))]
                    (P{x : Tm(W(A, x.B{x}))} : Ty,
                     p{x : Tm(A),
                       y : Tm(Î (B{x}, _. W(A, x.B{x}))),
                       z : Tm(Î (B{x}, x'. P{ï¹«(y, x')}))} : Tm(P{sup(x, y)}) )
                       : Tm(P{t})


equation Wind(sup(a, f), x. P{x}, x y z. p{x, y, z}) -->
         p{a, f, Î»(x. Wind(ï¹«(f, x), x. P{x}, x y z. p{x, y, z}))}

constructor w () (a : Tm(U), b{x : Tm(El(a))} : Tm(U)) : Tm(U)
equation El(w(a, x.b{x})) --> W(El(a), x.El(b{x}))

(* empty type *)
constructor âˆ… () () : Ty
(* we add âˆ…ind as a constructor,
   allowing us to omit P *)
constructor âˆ…ind (P : Ty) (x : Tm(âˆ…)) : Tm(P)

constructor câˆ… () () : Tm(U)
equation El(câˆ…) --> âˆ…

(* singleton type *)
constructor â‹† () () : Ty
constructor I () () : Tm(â‹†)

destructor â‹†ind () [x : Tm(â‹†)]
                (P {x : Tm(â‹†)} : Ty,
                 p : Tm(P{I}))
                : Tm(P{x})
equation â‹†ind(I, x. P{x}, p) --> p

constructor câ‹† () () : Tm(U)
equation El(câ‹†) --> â‹†

(* booleans *)
constructor ğ”¹ () () : Ty
constructor true () () : Tm(ğ”¹)
constructor false () () : Tm(ğ”¹)

destructor if () [x : Tm(ğ”¹)]
                 (P{x : Tm(ğ”¹)} : Ty,
                  a : Tm(P{true}),
                  b : Tm(P{false})) : Tm(P{x})
equation if(true, x.P{x}, a, b) --> a
equation if(false, x.P{x}, a, b) --> b

constructor cğ”¹ () () : Tm(U)
equation El(cğ”¹) --> ğ”¹


(* heterogeneous observational equality *)
(* because we have a universe, we will not need type equality,
   only term equality *)

constructor Eq () (A : Ty, a : Tm(A), B : Ty, b : Tm(B)) : Ty

constructor refl (A : Ty, a : Tm(A)) ()
                 (A / B : Ty, a / b : Tm(B)) : Tm(Eq(A, a, B, b))

(* in our formulation, symmetry and transitivity will not be derivable,
   so we have them in the definition of equality *)

constructor sym (A : Ty, a : Tm(A), B : Ty, b : Tm(B))
                (p : Tm(Eq(B, b, A, a))) : Tm(Eq(A, a, B, b))

constructor trans (A : Ty, a : Tm(A), C : Ty, c : Tm(C))
                  (B : Ty, b : Tm(B), p : Tm(Eq(A, a, B, b)), q : Tm(Eq(B, b, C, c)))
                  : Tm(Eq(A, a, C, c))

(* some of the axioms defining the observational equality *)

constructor EqÎ Î _i (A : Ty,  B{x : Tm(A)} : Ty,   f : Tm(Î (A, x.B{x})),
                    A' : Ty, B'{x : Tm(A')} : Ty, f' : Tm(Î (A', x.B'{x})))
                   (p {x : Tm(A), x' : Tm(A'), e : Tm(Eq(A, x, A', x'))}
                    : Tm(Eq(B{x}, ï¹«(f, x), B'{x'}, ï¹«(f', x'))))
                   : Tm(Eq(Î (A, x.B{x}), f, Î (A', x.B'{x}), f'))

destructor EqÎ Î _e (A : Ty,  B{x : Tm(A)} : Ty,   f : Tm(Î (A, x.B{x})),
                   A' : Ty, B'{x : Tm(A')} : Ty, f' : Tm(Î (A', x.B'{x})))
                  [p : Tm(Eq(Î (A, x.B{x}), f, Î (A', x.B'{x}), f'))]
                  (x : Tm(A), x' : Tm(A'), e : Tm(Eq(A, x, A', x')))
                  : Tm(Eq(B{x}, ï¹«(f, x), B'{x'}, ï¹«(f', x')))

constructor EqWW_i (A : Ty,  B {x : Tm(A )} : Ty, a  : Tm(A ), f  : Tm(Î (B {a }, _. W(A,  x .B {x }))),
                    A' : Ty, B'{x : Tm(A')} : Ty, a' : Tm(A'), f' : Tm(Î (B'{a'}, _. W(A', x'.B'{x'}))))
                   (p1 : Tm(Eq(A, a, A', a')),
                    p {x : Tm(B{a}), x' : Tm(B'{a'}), e : Tm(Eq(B{a}, x, B'{a'}, x'))}
                    : Tm(Eq(W(A, x.B{x}), ï¹«(f, x), W(A', x'.B'{x'}), ï¹«(f', x'))))
                   : Tm(Eq(W(A, x.B{x}), sup(a, f), W(A', x'.B'{x'}), sup(a', f')))

destructor EqWW_e1 (A : Ty,  B {x : Tm(A )} : Ty, a  : Tm(A ), f  : Tm(Î (B {a }, _. W(A,  x .B {x }))),
                   A' : Ty, B'{x : Tm(A')} : Ty, a' : Tm(A'), f' : Tm(Î (B'{a'}, _. W(A', x'.B'{x'}))))
                  [p : Tm(Eq(W(A, x.B{x}), sup(a, f), W(A', x'.B'{x'}), sup(a', f')))] ()
                  : Tm(Eq(A, a, A', a'))

destructor EqWW_e2 (A : Ty,  B {x : Tm(A )} : Ty, a  : Tm(A ), f  : Tm(Î (B {a }, _. W(A,  x .B {x }))),
                   A' : Ty, B'{x : Tm(A')} : Ty, a' : Tm(A'), f' : Tm(Î (B'{a'}, _. W(A', x'.B'{x'}))))
                  [p : Tm(Eq(W(A, x.B{x}), sup(a, f), W(A', x'.B'{x'}), sup(a', f')))]
                  (x : Tm(B{a}), x' : Tm(B'{a'}), e : Tm(Eq(B{a}, x, B'{a'}, x')))
                  : Tm(Eq(W(A, x.B{x}), ï¹«(f, x), W(A', x'.B'{x'}), ï¹«(f', x')))

constructor EqUUÏ€Ï€_i (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                      a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                     (p1 : Tm(Eq(U, a', U, a)),
                      p2 {x' : Tm(El(a')), x : Tm(El(a)), e : Tm(Eq(U, a', U, a))}
                       : Tm(Eq(U, b{x}, U, b'{x'})))
                     : Tm(Eq(U, Ï€(a, x. b{x}), U, Ï€(a', x'. b'{x'})))

destructor EqUUÏ€Ï€_e1  (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                       a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                      [p : Tm(Eq(U, Ï€(a, x. b{x}), U, Ï€(a', x'. b'{x'})))]
                      ()
                      : Tm(Eq(U, a', U, a))

destructor EqUUÏ€Ï€_e2  (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                       a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                      [p : Tm(Eq(U, Ï€(a, x. b{x}), U, Ï€(a', x'. b'{x'})))]
                      (x' : Tm(El(a')), x : Tm(El(a)), e : Tm(Eq(U, a', U, a)))
                      : Tm(Eq(U, b{x}, U, b'{x'}))

constructor EqUUww_i (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                      a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                     (p1 : Tm(Eq(U, a', U, a)),
                      p2 {x : Tm(El(a)), x' : Tm(El(a')), e : Tm(Eq(U, a, U, a'))}
                       : Tm(Eq(U, b{x}, U, b'{x'})))
                     : Tm(Eq(U, w(a, x. b{x}), U, w(a', x'. b'{x'})))

destructor EqUUww_e1  (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                       a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                      [p : Tm(Eq(U, w(a, x. b{x}), U, w(a', x'. b'{x'})))]
                      ()
                      : Tm(Eq(U, a, U, a'))

destructor EqUUww_e2  (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                       a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                      [p : Tm(Eq(U, w(a, x. b{x}), U, w(a', x'. b'{x'})))]
                      (x : Tm(El(a)), x' : Tm(El(a')), e : Tm(Eq(U, a, U, a')))
                      : Tm(Eq(U, b{x}, U, b'{x'}))

(* ... *)
(* I'm omitting some constructors/destructors for equality because there are many
    and in the following we will not need all of them *)

destructor cast () [a : Tm(U)] (b : Tm(U), e : Tm(Eq(U, a, U, b)), t : Tm(El(a))) : Tm(El(b))

equation cast(Ï€(a, x. b{x}), Ï€(a', x'. b'{x'}), e, t)
    -->  Î»(x'.
            let e1 := EqUUÏ€Ï€_e1(e) in
            let x  := cast(a', a, e1, x') in
            cast(b{x}, b'{x'}, EqUUÏ€Ï€_e2(x, x', e1), ï¹«(t, x)))

equation cast(w(a, x. b{x}), w(a', x'. b'{x'}), e, sup(t, u))
    --> let e1 := EqUUww_e1(e) in
        let t' := cast(a, a', e1, t) in
        sup(t', x'.
            let x := cast(b'{t'}, b{t}, EqUUww_e2(t, t', e1), x') in
            cast(w(a, x.b{x}), w(a', x'. b'{x'}), e, ï¹«(u, x)))

equation cast(cğ”¹, cğ”¹, e, t) --> t
equation cast(câ‹†, câ‹†, e, t) --> t
equation cast(câˆ…, câˆ…, e, t) --> t

(* coherence of cast *)
destructor castEq (a : Tm(U), b : Tm(U)) [e : Tm(Eq(U, a, U, b))] (t : Tm(El(a)))
        : Tm(Eq(El(a), t, El(b), cast(a, b, e, t)))

(* === END OF DEF OF THE THEORY === *)

(* from now on we only define things in the theory *)

(* we can derive congruence *)
let cong (A : Ty, x : Tm(A), y : Tm(A), e : Tm(Eq(A, x, A, y)),
          B{x : Tm(A)} : Ty, f{x:Tm(A)} : Tm(B{x}))
          : Tm(Eq(B{x}, f{x}, B{y}, f{y}))
    := EqÎ Î _e([Tm(Eq(Î (A, x.B{x}), Î»(x.f{x}), Î (A, x.B{x}), Î»(x.f{x})))]
              refl, x, y, e)

(* note that by taking a U-valued f in cong, we get a version of
   the axiom "R" (from the original "Observational Equality, Now!"
   paper) for small types. this is why we haven't added this axiom.
   on the other hand, this is not enough to derive sym and trans,
   given that equality is not small. this is why we have included
   them as axioms. *)


(* we can derive substitution for small types *)
let subst (A : Ty, x : Tm(A), y : Tm(A), p : Tm(Eq(A, x, A, y)),
           b{x : Tm(A)} : Tm(U), z : Tm(El(b{x})))
        : Tm(El(b{y}))
    := cast(b{x}, b{y}, cong(A, x, y, p, _. U, x. b{x}), z)

(* we can derive functional extensionality for functions of small types *)
let funext (a : Tm(U), b{x:Tm(El(a))} : Tm(U),
            f : Tm(Î (El(a), x. El(b{x}))), f' : Tm(Î (El(a), x. El(b{x}))),
            p {x : Tm(El(a))} : Tm(Eq(El(b{x}), ï¹«(f, x), El(b{x}), ï¹«(f', x))))
            : Tm(Eq(Î (El(a), x. El(b{x})), f, Î (El(a), x. El(b{x})), f'))
    := EqÎ Î _i(x x' e.
                let p : Tm(Eq(Î (El(a), x. El(b{x})), f', Î (El(a), x. El(b{x})), f')) := refl in
                let e' := EqÎ Î _e(p, x, x', e) in
                trans(El(b{x}), ï¹«(f', x), p{x}, e'))

let tr (b : Tm(ğ”¹)) : Tm(U) := if(b, _. U, câ‹†, câˆ…)

let câ„• : Tm(U) := w(cğ”¹, b. tr(b))
let â„• : Ty := El(câ„•)

let 0 : Tm(â„•) := sup(false, Î»(x. âˆ…ind(x)))
let S (n : Tm(â„•)) : Tm(â„•) := sup(true, Î»(_. n))

let â‹†irrel (x : Tm(â‹†)) : Tm(Eq(â‹†, I, â‹†, x)) := â‹†ind(x, y. Eq(â‹†, I, â‹†, y), refl)

let â„•ind (n : Tm(â„•), P{n : Tm(â„•)} : Tm(U), p0 : Tm(El(P{0})),
          ps{n : Tm(â„•), e : Tm(El(P{n}))} : Tm(El(P{S(n)})))
        : Tm(El(P{n}))
    :=
    let motive : Tm(Î (ğ”¹, _. U)) :=
        Î»(b. Ï€(Ï€(tr(b), _. câ„•), f.
               Ï€(Ï€(tr(b), n. P{ï¹«(f, n)}), _. P{sup(b, f)})))
    in
    let b1 : Tm(El(ï¹«(motive, true))) :=
        Î»(f. Î»(frec.
        let m := ï¹«(f, I) in
        let Sm' : Tm(â„•) := sup(true, f) in
        let e : Tm(Eq(â„•, S(m), â„•, Sm')) :=
            EqWW_i(refl, _ x' _. cong(â‹†, I, x', â‹†irrel(x'), _. â„•, x. ï¹«(f, x))) in
        let p' := ps{m, ï¹«(frec, I)} in
        cast(P{S(m)}, P{Sm'}, cong(â„•, S(m), Sm', e, _. U, x. P{x}), p')))
    in
    let b2 : Tm(El(ï¹«(motive, false))) :=
        Î»(f. Î»(_.
        let 0' : Tm(â„•) := sup(false, f) in
        let e : Tm(Eq(â„•, 0, â„•, 0')) :=
            EqWW_i(refl, x _ _. âˆ…ind(x)) in
        cast(P{0}, P{0'}, cong(â„•, 0, 0', e, _. U, x. P{x}), p0)))
    in
    Wind(n, x. El(P{x}), b f frec.
        let M := if(b, x. El(ï¹«(motive, x)), b1, b2) in
        ï¹«(ï¹«(M, f), frec))

(* large elimination *)
let â„•indU (n : Tm(â„•), p0 : Tm(U), ps{n : Tm(â„•), e : Tm(U)} : Tm(U))
        : Tm(U)
    :=
    Wind(n, _. U, b f frec.
        let M := if(b, x. Î (Î (El(tr(x)), _. â„•), _. Î (Î (El(tr(x)), _. U), _. U)),
                      Î»(f. Î»(frec. ps{ï¹«(f, I), ï¹«(frec, I)})),
                      Î»(_. Î»(_. p0))) in
        ï¹«(ï¹«(M, f), frec))

let 0â‰¢Sn (n : Tm(â„•), p : Tm(Eq(â„•, 0, â„•, S(n)))) : Tm(âˆ…)
    := let câˆ…â‰¡câ‹† := cong(â„•, 0, S(n), p, _.U, n. â„•indU(n, câ‹†, _ _. câˆ…)) in
    cast([Tm(U)] câ‹†, câˆ…, câˆ…â‰¡câ‹†, I)

(* constructor TODO (A : Ty) () : Tm(A) *)