
(* Heterogeneous OTT with a Taski-style universe *)

(* Judgment forms *)
sort Ty ()
sort Tm (A : Ty)

(* Taski-style universe *)
constructor U () () : Ty
destructor El () [A : Tm(U)] () : Ty

(* Dependent products *)
constructor Œ†   ()
                (A : Ty, B{x : Tm(A)} : Ty)
                : Ty

constructor Œª   (A : Ty, B{x : Tm(A)} : Ty)
                (t{x : Tm(A)} : Tm(B{x}))
                : Tm(Œ†(A, x. B{x}))

destructor Ôπ´   (A : Ty, B{x : Tm(A)} : Ty)
                [t : Tm(Œ†(A, x. B{x}))]
                (u : Tm(A))
                : Tm(B{u})

equation Ôπ´(Œª(x. t{x}), u) --> t{u}

constructor œÄ () (a : Tm(U), b{_ : Tm(El(a))} : Tm(U)) : Tm(U)
equation El(œÄ(a, x.b{x})) --> Œ†(El(a), x. El(b{x}))


(* W Types *)
constructor W () (A : Ty, B{x : Tm(A)} : Ty) : Ty
constructor sup (A : Ty, B{x : Tm(A)} : Ty)
                (a : Tm(A), f : Tm(Œ†(B{a}, _. W(A, x.B{x}))))
                : Tm(W(A, x.B{x}))

destructor Wind     (A : Ty, B{x : Tm(A)} : Ty)
                    [t : Tm(W(A, x.B{x}))]
                    (P{x : Tm(W(A, x.B{x}))} : Ty,
                     p{x : Tm(A),
                       y : Tm(Œ†(B{x}, _. W(A, x.B{x}))),
                       z : Tm(Œ†(B{x}, x'. P{Ôπ´(y, x')}))} : Tm(P{sup(x, y)}) )
                       : Tm(P{t})


equation Wind(sup(a, f), x. P{x}, x y z. p{x, y, z}) -->
         p{a, f, Œª(x. Wind(Ôπ´(f, x), x. P{x}, x y z. p{x, y, z}))}

constructor w () (a : Tm(U), b{x : Tm(El(a))} : Tm(U)) : Tm(U)
equation El(w(a, x.b{x})) --> W(El(a), x.El(b{x}))

(* empty type *)
constructor ‚àÖ () () : Ty
(* we add ‚àÖind as a constructor,
   allowing us to omit P *)
constructor ‚àÖind (P : Ty) (x : Tm(‚àÖ)) : Tm(P)

constructor c‚àÖ () () : Tm(U)
equation El(c‚àÖ) --> ‚àÖ

(* singleton type *)
constructor ‚ãÜ () () : Ty
constructor I () () : Tm(‚ãÜ)

destructor ‚ãÜind () [x : Tm(‚ãÜ)]
                (P {x : Tm(‚ãÜ)} : Ty,
                 p : Tm(P{I}))
                : Tm(P{x})
equation ‚ãÜind(I, x. P{x}, p) --> p

constructor c‚ãÜ () () : Tm(U)
equation El(c‚ãÜ) --> ‚ãÜ

(* booleans *)
constructor ùîπ () () : Ty
constructor true () () : Tm(ùîπ)
constructor false () () : Tm(ùîπ)

destructor if () [x : Tm(ùîπ)]
                 (P{x : Tm(ùîπ)} : Ty,
                  a : Tm(P{true}),
                  b : Tm(P{false})) : Tm(P{x})
equation if(true, x.P{x}, a, b) --> a
equation if(false, x.P{x}, a, b) --> b

constructor cùîπ () () : Tm(U)
equation El(cùîπ) --> ùîπ


(* heterogeneous observational equality *)
(* because we have a universe, we will not need type equality,
   only term equality *)

constructor Eq () (A : Ty, a : Tm(A), B : Ty, b : Tm(B)) : Ty

constructor refl (A : Ty, a : Tm(A)) ()
                 (A / B : Ty, a / b : Tm(B)) : Tm(Eq(A, a, B, b))

(* in our formulation, symmetry and transitivity will not be derivable,
   so we have them in the definition of equality *)

constructor sym (A : Ty, a : Tm(A), B : Ty, b : Tm(B))
                (p : Tm(Eq(B, b, A, a))) : Tm(Eq(A, a, B, b))

constructor trans (A : Ty, a : Tm(A), C : Ty, c : Tm(C))
                  (B : Ty, b : Tm(B), p : Tm(Eq(A, a, B, b)), q : Tm(Eq(B, b, C, c)))
                  : Tm(Eq(A, a, C, c))

(* some of the axioms defining the observational equality *)

constructor EqŒ†Œ†_i (A : Ty,  B{x : Tm(A)} : Ty,   f : Tm(Œ†(A, x.B{x})),
                    A' : Ty, B'{x : Tm(A')} : Ty, f' : Tm(Œ†(A', x.B'{x})))
                   (p {x : Tm(A), x' : Tm(A'), e : Tm(Eq(A, x, A', x'))}
                    : Tm(Eq(B{x}, Ôπ´(f, x), B'{x'}, Ôπ´(f', x'))))
                   : Tm(Eq(Œ†(A, x.B{x}), f, Œ†(A', x.B'{x}), f'))

destructor EqŒ†Œ†_e (A : Ty,  B{x : Tm(A)} : Ty,   f : Tm(Œ†(A, x.B{x})),
                   A' : Ty, B'{x : Tm(A')} : Ty, f' : Tm(Œ†(A', x.B'{x})))
                  [p : Tm(Eq(Œ†(A, x.B{x}), f, Œ†(A', x.B'{x}), f'))]
                  (x : Tm(A), x' : Tm(A'), e : Tm(Eq(A, x, A', x')))
                  : Tm(Eq(B{x}, Ôπ´(f, x), B'{x'}, Ôπ´(f', x')))

constructor EqWW_i (A : Ty,  B {x : Tm(A )} : Ty, a  : Tm(A ), f  : Tm(Œ†(B {a }, _. W(A,  x .B {x }))),
                    A' : Ty, B'{x : Tm(A')} : Ty, a' : Tm(A'), f' : Tm(Œ†(B'{a'}, _. W(A', x'.B'{x'}))))
                   (p1 : Tm(Eq(A, a, A', a')),
                    p {x : Tm(B{a}), x' : Tm(B'{a'}), e : Tm(Eq(B{a}, x, B'{a'}, x'))}
                    : Tm(Eq(W(A, x.B{x}), Ôπ´(f, x), W(A', x'.B'{x'}), Ôπ´(f', x'))))
                   : Tm(Eq(W(A, x.B{x}), sup(a, f), W(A', x'.B'{x'}), sup(a', f')))

destructor EqWW_e1 (A : Ty,  B {x : Tm(A )} : Ty, a  : Tm(A ), f  : Tm(Œ†(B {a }, _. W(A,  x .B {x }))),
                   A' : Ty, B'{x : Tm(A')} : Ty, a' : Tm(A'), f' : Tm(Œ†(B'{a'}, _. W(A', x'.B'{x'}))))
                  [p : Tm(Eq(W(A, x.B{x}), sup(a, f), W(A', x'.B'{x'}), sup(a', f')))] ()
                  : Tm(Eq(A, a, A', a'))

destructor EqWW_e2 (A : Ty,  B {x : Tm(A )} : Ty, a  : Tm(A ), f  : Tm(Œ†(B {a }, _. W(A,  x .B {x }))),
                   A' : Ty, B'{x : Tm(A')} : Ty, a' : Tm(A'), f' : Tm(Œ†(B'{a'}, _. W(A', x'.B'{x'}))))
                  [p : Tm(Eq(W(A, x.B{x}), sup(a, f), W(A', x'.B'{x'}), sup(a', f')))]
                  (x : Tm(B{a}), x' : Tm(B'{a'}), e : Tm(Eq(B{a}, x, B'{a'}, x')))
                  : Tm(Eq(W(A, x.B{x}), Ôπ´(f, x), W(A', x'.B'{x'}), Ôπ´(f', x')))

constructor EqUUœÄœÄ_i (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                      a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                     (p1 : Tm(Eq(U, a', U, a)),
                      p2 {x' : Tm(El(a')), x : Tm(El(a)), e : Tm(Eq(U, a', U, a))}
                       : Tm(Eq(U, b{x}, U, b'{x'})))
                     : Tm(Eq(U, œÄ(a, x. b{x}), U, œÄ(a', x'. b'{x'})))

destructor EqUUœÄœÄ_e1  (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                       a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                      [p : Tm(Eq(U, œÄ(a, x. b{x}), U, œÄ(a', x'. b'{x'})))]
                      ()
                      : Tm(Eq(U, a', U, a))

destructor EqUUœÄœÄ_e2  (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                       a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                      [p : Tm(Eq(U, œÄ(a, x. b{x}), U, œÄ(a', x'. b'{x'})))]
                      (x' : Tm(El(a')), x : Tm(El(a)), e : Tm(Eq(U, a', U, a)))
                      : Tm(Eq(U, b{x}, U, b'{x'}))

constructor EqUUww_i (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                      a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                     (p1 : Tm(Eq(U, a', U, a)),
                      p2 {x : Tm(El(a)), x' : Tm(El(a')), e : Tm(Eq(U, a, U, a'))}
                       : Tm(Eq(U, b{x}, U, b'{x'})))
                     : Tm(Eq(U, w(a, x. b{x}), U, w(a', x'. b'{x'})))

destructor EqUUww_e1  (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                       a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                      [p : Tm(Eq(U, w(a, x. b{x}), U, w(a', x'. b'{x'})))]
                      ()
                      : Tm(Eq(U, a, U, a'))

destructor EqUUww_e2  (a  : Tm(U), b {x  : Tm(El(a ))} : Tm(U),
                       a' : Tm(U), b'{x' : Tm(El(a'))} : Tm(U))
                      [p : Tm(Eq(U, w(a, x. b{x}), U, w(a', x'. b'{x'})))]
                      (x : Tm(El(a)), x' : Tm(El(a')), e : Tm(Eq(U, a, U, a')))
                      : Tm(Eq(U, b{x}, U, b'{x'}))

(* ... *)
(* I'm omitting some constructors/destructors for equality because there are many
    and in the following we will not need all of them *)

destructor cast () [a : Tm(U)] (b : Tm(U), e : Tm(Eq(U, a, U, b)), t : Tm(El(a))) : Tm(El(b))

equation cast(œÄ(a, x. b{x}), œÄ(a', x'. b'{x'}), e, t)
    -->  Œª(x'.
            let e1 := EqUUœÄœÄ_e1(e) in
            let x  := cast(a', a, e1, x') in
            cast(b{x}, b'{x'}, EqUUœÄœÄ_e2(x, x', e1), Ôπ´(t, x)))

equation cast(w(a, x. b{x}), w(a', x'. b'{x'}), e, sup(t, u))
    --> let e1 := EqUUww_e1(e) in
        let t' := cast(a, a', e1, t) in
        sup(t', x'.
            let x := cast(b'{t'}, b{t}, EqUUww_e2(t, t', e1), x') in
            cast(w(a, x.b{x}), w(a', x'. b'{x'}), e, Ôπ´(u, x)))

equation cast(cùîπ, cùîπ, e, t) --> t
equation cast(c‚ãÜ, c‚ãÜ, e, t) --> t
equation cast(c‚àÖ, c‚àÖ, e, t) --> t

(* coherence of cast *)
destructor castEq (a : Tm(U), b : Tm(U)) [e : Tm(Eq(U, a, U, b))] (t : Tm(El(a)))
        : Tm(Eq(El(a), t, El(b), cast(a, b, e, t)))

(* === END OF DEF OF THE THEORY === *)

(* from now on we only define things in the theory *)

(* we can derive congruence *)
let cong (A : Ty, x : Tm(A), y : Tm(A), e : Tm(Eq(A, x, A, y)),
          B{x : Tm(A)} : Ty, f{x:Tm(A)} : Tm(B{x}))
          : Tm(Eq(B{x}, f{x}, B{y}, f{y}))
    := EqŒ†Œ†_e([Tm(Eq(Œ†(A, x.B{x}), Œª(x.f{x}), Œ†(A, x.B{x}), Œª(x.f{x})))]
              refl, x, y, e)

(* note that by taking a U-valued f in cong, we get a version of
   the axiom "R" (from the original "Observational Equality, Now!"
   paper) for small types. this is why we haven't added this axiom.
   on the other hand, this is not enough to derive sym and trans,
   given that equality is not small. this is why we have included
   them as axioms. *)


(* we can derive substitution for small types *)
let subst (A : Ty, x : Tm(A), y : Tm(A), p : Tm(Eq(A, x, A, y)),
           b{x : Tm(A)} : Tm(U), z : Tm(El(b{x})))
        : Tm(El(b{y}))
    := cast(b{x}, b{y}, cong(A, x, y, p, _. U, x. b{x}), z)

(* we can derive functional extensionality for functions of small types *)
let funext (a : Tm(U), b{x:Tm(El(a))} : Tm(U),
            f : Tm(Œ†(El(a), x. El(b{x}))), f' : Tm(Œ†(El(a), x. El(b{x}))),
            p {x : Tm(El(a))} : Tm(Eq(El(b{x}), Ôπ´(f, x), El(b{x}), Ôπ´(f', x))))
            : Tm(Eq(Œ†(El(a), x. El(b{x})), f, Œ†(El(a), x. El(b{x})), f'))
    := EqŒ†Œ†_i(x x' e.
                let p : Tm(Eq(Œ†(El(a), x. El(b{x})), f', Œ†(El(a), x. El(b{x})), f')) := refl in
                let e' := EqŒ†Œ†_e(p, x, x', e) in
                trans(El(b{x}), Ôπ´(f', x), p{x}, e'))

let tr (b : Tm(ùîπ)) : Tm(U) := if(b, _. U, c‚ãÜ, c‚àÖ)

let c‚Ñï : Tm(U) := w(cùîπ, b. tr(b))
let ‚Ñï : Ty := El(c‚Ñï)

let 0 : Tm(‚Ñï) := sup(false, Œª(x. ‚àÖind(x)))
let S (n : Tm(‚Ñï)) : Tm(‚Ñï) := sup(true, Œª(_. n))

let ‚ãÜirrel (x : Tm(‚ãÜ)) : Tm(Eq(‚ãÜ, I, ‚ãÜ, x)) := ‚ãÜind(x, y. Eq(‚ãÜ, I, ‚ãÜ, y), refl)

let ‚Ñïind (n : Tm(‚Ñï), P{n : Tm(‚Ñï)} : Tm(U), p0 : Tm(El(P{0})),
          ps{n : Tm(‚Ñï), e : Tm(El(P{n}))} : Tm(El(P{S(n)})))
        : Tm(El(P{n}))
    :=
    let motive : Tm(Œ†(ùîπ, _. U)) :=
        Œª(b. œÄ(œÄ(tr(b), _. c‚Ñï), f.
               œÄ(œÄ(tr(b), n. P{Ôπ´(f, n)}), _. P{sup(b, f)})))
    in
    let b1 : Tm(El(Ôπ´(motive, true))) :=
        Œª(f. Œª(frec.
        let m := Ôπ´(f, I) in
        let Sm' : Tm(‚Ñï) := sup(true, f) in
        let e : Tm(Eq(‚Ñï, S(m), ‚Ñï, Sm')) :=
            EqWW_i(refl, _ x' _. cong(‚ãÜ, I, x', ‚ãÜirrel(x'), _. ‚Ñï, x. Ôπ´(f, x))) in
        let p' := ps{m, Ôπ´(frec, I)} in
        cast(P{S(m)}, P{Sm'}, cong(‚Ñï, S(m), Sm', e, _. U, x. P{x}), p')))
    in
    let b2 : Tm(El(Ôπ´(motive, false))) :=
        Œª(f. Œª(_.
        let 0' : Tm(‚Ñï) := sup(false, f) in
        let e : Tm(Eq(‚Ñï, 0, ‚Ñï, 0')) :=
            EqWW_i(refl, x _ _. ‚àÖind(x)) in
        cast(P{0}, P{0'}, cong(‚Ñï, 0, 0', e, _. U, x. P{x}), p0)))
    in
    Wind(n, x. El(P{x}), b f frec.
        let M := if(b, x. El(Ôπ´(motive, x)), b1, b2) in
        Ôπ´(Ôπ´(M, f), frec))

(* large elimination *)
let ‚ÑïindU (n : Tm(‚Ñï), p0 : Tm(U), ps{n : Tm(‚Ñï), e : Tm(U)} : Tm(U))
        : Tm(U)
    :=
    Wind(n, _. U, b f frec.
        let M := if(b, x. Œ†(Œ†(El(tr(x)), _. ‚Ñï), _. Œ†(Œ†(El(tr(x)), _. U), _. U)),
                      Œª(f. Œª(frec. ps{Ôπ´(f, I), Ôπ´(frec, I)})),
                      Œª(_. Œª(_. p0))) in
        Ôπ´(Ôπ´(M, f), frec))

let 0‚â¢Sn (n : Tm(‚Ñï), p : Tm(Eq(‚Ñï, 0, ‚Ñï, S(n)))) : Tm(‚àÖ)
    := let c‚àÖ‚â°c‚ãÜ := cong(‚Ñï, 0, S(n), p, _.U, n. ‚ÑïindU(n, c‚ãÜ, _ _. c‚àÖ)) in
    cast([Tm(U)] c‚ãÜ, c‚àÖ, c‚àÖ‚â°c‚ãÜ, I)

(* constructor TODO (A : Ty) () : Tm(A) *)