
(* Homogeneous OTT with a type-in-type Coquand-style universe *)

(* Judgment forms *)
sort Ty ()
sort Tm (A : Ty)

(* type-in-type Coquand-style universe *)
constructor U () () : Ty
constructor c () (A : Ty) : Tm(U)
destructor El () [a : Tm(U)] () : Ty
equation El(c(A)) --> A
equation c(El(A)) --> A


(* Dependent products *)
constructor Î    ()
                (A : Ty, B{x : Tm(A)} : Ty)
                : Ty

constructor Î»   (A : Ty, B{x : Tm(A)} : Ty)
                (t{x : Tm(A)} : Tm(B{x}))
                : Tm(Î (A, x. B{x}))

destructor ï¹«   (A : Ty, B{x : Tm(A)} : Ty)
                [t : Tm(Î (A, x. B{x}))]
                (u : Tm(A))
                : Tm(B{u})

equation ï¹«(Î»(x. t{x}), u) --> t{u}

(* W Types *)
constructor W () (A : Ty, B{x : Tm(A)} : Ty) : Ty
constructor sup (A : Ty, B{x : Tm(A)} : Ty)
                (a : Tm(A), f : Tm(Î (B{a}, _. W(A, x.B{x}))))
                : Tm(W(A, x.B{x}))

destructor Wind     (A : Ty, B{x : Tm(A)} : Ty)
                    [t : Tm(W(A, x.B{x}))]
                    (P{x : Tm(W(A, x.B{x}))} : Ty,
                     p{x : Tm(A),
                       y : Tm(Î (B{x}, _. W(A, x.B{x}))),
                       z : Tm(Î (B{x}, x'. P{ï¹«(y, x')}))} : Tm(P{sup(x, y)}) )
                       : Tm(P{t})


equation Wind(sup(a, f), x. P{x}, x y z. p{x, y, z}) -->
         p{a, f, Î»(x. Wind(ï¹«(f, x), x. P{x}, x y z. p{x, y, z}))}

(* empty type *)
constructor âˆ… () () : Ty
(* we add âˆ…ind as a constructor,
   allowing us to omit P *)
constructor âˆ…ind (P : Ty) (x : Tm(âˆ…)) : Tm(P)

(* singleton type *)
constructor â‹† () () : Ty
constructor I () () : Tm(â‹†)

destructor â‹†ind () [x : Tm(â‹†)]
                (P {x : Tm(â‹†)} : Ty,
                 p : Tm(P{I}))
                : Tm(P{x})
equation â‹†ind(I, x. P{x}, p) --> p

(* booleans *)
constructor ğ”¹ () () : Ty
constructor true () () : Tm(ğ”¹)
constructor false () () : Tm(ğ”¹)

destructor if () [x : Tm(ğ”¹)]
                 (P{x : Tm(ğ”¹)} : Ty,
                  a : Tm(P{true}),
                  b : Tm(P{false})) : Tm(P{x})
equation if(true, x.P{x}, a, b) --> a
equation if(false, x.P{x}, a, b) --> b


(* homogeneous observational equality *)
(* because we have a universe, we will not need type equality,
   only term equality *)

constructor Eq () (A : Ty, a : Tm(A), b : Tm(A)) : Ty

constructor refl (A : Ty, a : Tm(A), b : Tm(A)) ()
                 (a = b : Tm(A))
                 : Tm(Eq(A, a, b))

destructor cast () [A : Ty] (B : Ty, e : Tm(Eq(U, c(A), c(B))), t : Tm(A)) : Tm(B)

(* when defining observational equality in a homogeneous way,
   we need to add the following as an axiom *)
destructor R (A : Ty, x : Tm(A), x' : Tm(A)) [e : Tm(Eq(A, x, x'))]
              (P {x : Tm(A)} : Ty) : Tm(Eq(U, c(P{x}), c(P{x'})))

(* we can now derive substitution *)
let subst (A : Ty, x : Tm(A), y : Tm(A), p : Tm(Eq(A, x, y)),
           P{x : Tm(A)} : Ty, z : Tm(P{x}))
        : Tm(P{y})
    := cast(P{x}, P{y}, R(p, x. P{x}), z)

(* I think we also could derive dependent subst (J) by postulating
   irrelevance of equality, but we will not need this here *)

(* Pujet and Tabareau instead consider a theory with primitive subst
   for propositions, which then allow us to derive R.
   the reason we prefer to have R as primitive is because we do not
   have a distinguished sort for propositions, so we cannot just
   add subst for types as an axiom without breaking canonicity *)


(* we can derive sym and trans *)

let sym' (A : Ty, x : Tm(A), y : Tm(A), p : Tm(Eq(A, x, y)))
    : Tm(Eq(A, y, x))
    := subst(A, x, y, p, z. Eq(A, z, x), refl)

let trans' (A : Ty, x : Tm(A), y : Tm(A), z : Tm(A),
            p : Tm(Eq(A, x, y)), q : Tm(Eq(A, y, z)))
            : Tm(Eq(A, x, z))
    := subst(A, y, z, q, x'. Eq(A, x, x'), p)

(* now we now sym and trans are justified by the theory, we add
   them as constructor, allowing us to omit some of the arguments.
   note that they then become opaque, but this is not a problem,
   since in observational type theory one does not compute equality proofs *)

constructor sym (A : Ty, x : Tm(A), y : Tm(A))
                (p : Tm(Eq(A, y, x)))
                : Tm(Eq(A, x, y))

constructor trans (A : Ty, x : Tm(A), z : Tm(A))
                  (y : Tm(A), p : Tm(Eq(A, x, y)), q : Tm(Eq(A, y, z)))
                : Tm(Eq(A, x, z))


(* some of the axioms defining the observational equality *)

constructor EqÎ _i  (A : Ty,  B{x : Tm(A)} : Ty,   f : Tm(Î (A, x.B{x})), f' : Tm(Î (A, x.B{x})))
                   (p {x : Tm(A)} : Tm(Eq(B{x}, ï¹«(f, x), ï¹«(f', x))))
                   : Tm(Eq(Î (A, x.B{x}), f, f'))

destructor EqÎ _e  (A : Ty,  B{x : Tm(A)} : Ty,   f : Tm(Î (A, x.B{x})), f' : Tm(Î (A, x.B{x})))
                  [p : Tm(Eq(Î (A, x.B{x}), f, f'))] (x : Tm(A))
                  : Tm(Eq(B{x}, ï¹«(f, x), ï¹«(f', x)))

constructor EqW_i (A : Ty,  B {x : Tm(A )} : Ty,
                   a  : Tm(A), f  : Tm(Î (B {a }, _. W(A, x.B{x}))),
                   a' : Tm(A), f' : Tm(Î (B {a'}, _. W(A, x.B{x}))))
                   (p1 : Tm(Eq(A, a, a')),
                    p2 {x : Tm(B{a})} :
                      let e := R(p1, x.B{x}) in
                      let x' := cast(B{a}, B{a'}, e, x) in
                      Tm(Eq(W(A, x.B{x}), ï¹«(f, x), ï¹«(f', x'))))
                   : Tm(Eq(W(A, x.B{x}), sup(a, f), sup(a', f')))

destructor EqW_e1 (A : Ty,  B{x : Tm(A)} : Ty,
                   a  : Tm(A), f  : Tm(Î (B {a }, _. W(A, x.B{x}))),
                   a' : Tm(A), f' : Tm(Î (B {a'}, _. W(A, x.B{x}))))
                   [p : Tm(Eq(W(A, x.B{x}), sup(a, f), sup(a', f')))]
                   () : Tm(Eq(A, a, a'))

destructor EqW_e2 (A : Ty,  B{x : Tm(A)} : Ty,
                   a  : Tm(A), f  : Tm(Î (B {a }, _. W(A, x.B{x}))),
                   a' : Tm(A), f' : Tm(Î (B {a'}, _. W(A, x.B{x}))))
                   [p : Tm(Eq(W(A, x.B{x}), sup(a, f), sup(a', f')))]
                   (x : Tm(B{a}))
                   : let e := R(EqW_e1(p), x.B{x}) in
                     let x' := cast(B{a}, B{a'}, e, x) in
                     Tm(Eq(W(A, x.B{x}), ï¹«(f, x), ï¹«(f', x')))


constructor EqUÎ Î _i (A  : Ty, B {x  : Tm(A )} : Ty,
                     A' : Ty, B'{x' : Tm(A')} : Ty)
                    (p1 : Tm(Eq(U, c(A), c(A'))),
                     p2 {x' : Tm(A')} :
                        let x := cast(A', A, sym(p1), x') in
                        Tm(Eq(U, c(B{x}), c(B'{x'}))))
                    : Tm(Eq(U, c(Î (A, x.B{x})), c(Î (A', x'.B'{x'}))))


destructor EqUÎ Î _e1  (A  : Ty, B {x  : Tm(A )} : Ty,
                      A' : Ty, B'{x' : Tm(A')} : Ty)
                     [p : Tm(Eq(U, c(Î (A, x.B{x})), c(Î (A', x'.B'{x'}))))] ()
                    : Tm(Eq(U, c(A), c(A')))

destructor EqUÎ Î _e2  (A  : Ty, B {x  : Tm(A )} : Ty,
                      A' : Ty, B'{x' : Tm(A')} : Ty)
                     [p : Tm(Eq(U, c(Î (A, x.B{x})), c(Î (A', x'.B'{x'}))))]
                     (x' : Tm(A'))
                    : let x := cast(A', A, sym(EqUÎ Î _e1(p)), x') in
                      Tm(Eq(U, c(B{x}), c(B'{x'})))

constructor EqUWW_i (A  : Ty, B {x  : Tm(A )} : Ty,
                     A' : Ty, B'{x' : Tm(A')} : Ty)
                    (p1 : Tm(Eq(U, c(A), c(A'))),
                     p2 {x : Tm(A)} :
                        let x' := cast(A, A', p1, x) in
                        Tm(Eq(U, c(B'{x'}), c(B{x}))))
                    : Tm(Eq(U, c(W(A, x.B{x})), c(W(A', x'.B'{x'}))))


destructor EqUWW_e1  (A  : Ty, B {x  : Tm(A )} : Ty,
                      A' : Ty, B'{x' : Tm(A')} : Ty)
                     [p : Tm(Eq(U, c(W(A, x.B{x})), c(W(A', x'.B'{x'}))))] ()
                    : Tm(Eq(U, c(A), c(A')))

destructor EqUWW_e2  (A  : Ty, B {x  : Tm(A )} : Ty,
                      A' : Ty, B'{x' : Tm(A')} : Ty)
                     [p : Tm(Eq(U, c(W(A, x.B{x})), c(W(A', x'.B'{x'}))))]
                     (x : Tm(A))
                    : let x' := cast(A, A', EqUWW_e1(p), x) in
                      Tm(Eq(U, c(B'{x'}), c(B{x})))

(* ... *)
(* I'm omitting some constructors/destructors for equality because there are many
    and in the following we will not need all of them *)


equation cast(Î (A, x. B{x}), Î (A', x'. B'{x'}), e, t)
    -->  Î»(x'.
            let x := cast(A', A, sym(EqUÎ Î _e1(e)), x') in
            cast(B{x}, B'{x'}, EqUÎ Î _e2(e, x'), ï¹«(t, x)))

equation cast(W(A, x. B{x}), W(A', x'. B'{x'}), e, sup(t, u))
    --> let t' := cast(A, A', EqUWW_e1(e), t) in
        sup(t', Î»(x'.
            let x := cast(B'{t'}, B{t}, EqUWW_e2(e, t), x') in
            cast(W(A, x.B{x}) :: Ty, W(A', x'. B'{x'}), e, ï¹«(u, x))))

equation cast(ğ”¹, ğ”¹, e, t) --> t

equation cast(â‹†, â‹†, e, t) --> t

equation cast(âˆ…, âˆ…, e, t) --> t

equation cast(U, U, e, t) --> t

(* coherence of cast *)
destructor castEq (A : Ty) [t : Tm(A)] (e : Tm(Eq(U, c(A), c(A))))
        : Tm(Eq(A, t, cast(A, A, e, t)))

(* === END OF DEF OF THE THEORY === *)

(* from now on we only define things in the theory *)

let cong' (A : Ty, x : Tm(A), y : Tm(A), e : Tm(Eq(A, x, y)),
           P : Ty, p {x : Tm(A)} : Tm(P))
          : Tm(Eq(P, p{x}, p{y}))
    := subst(A, x, y, e, z. Eq(P, p{x}, p{z}), refl)

(* once again, because we now know that cong is justified by
   the theory, we can add it as a symbol, allowing us to omit some arguments *)
destructor cong (A : Ty, x : Tm(A), y : Tm(A))
                [e : Tm(Eq(A, x, y))]
                (P : Ty, p {x : Tm(A)} : Tm(P))
            : Tm(Eq(P, p{x}, p{y}))

let Tr (b : Tm(ğ”¹)) : Ty := El(if(b, _. U, c(â‹†), c(âˆ…)))

let â„• : Ty := W(ğ”¹, b. Tr(b))

let 0 : Tm(â„•) := sup(false, Î»(x. âˆ…ind(x)))
let S (n : Tm(â„•)) : Tm(â„•) := sup(true, Î»(_. n))

let â‹†irrel (x : Tm(â‹†)) : Tm(Eq(â‹†, I, x)) := â‹†ind(x, y. Eq(â‹†, I, y), refl)

let â„•ind (n : Tm(â„•), P{n : Tm(â„•)} : Ty, p0 : Tm(P{0}),
          ps{n : Tm(â„•), e : Tm(P{n})} : Tm(P{S(n)}))
        : Tm(P{n})
    :=
    let motive : Tm(Î (ğ”¹, _. U)) :=
        Î»(b. c(Î (Î (Tr(b), _. â„•), f.
               Î (Î (Tr(b), n. P{ï¹«(f, n)}), _. P{sup(b, f)}))))
    in
    let b1 : Tm(El(ï¹«(motive, true))) :=
        Î»(f. Î»(frec.
        let m := ï¹«(f, I) in
        let Sm' : Tm(â„•) := sup(true, f) in
        let e : Tm(Eq(â„•, S(m), Sm')) :=
           EqW_i(refl, x'. cong(â‹†irrel(x'), â„•, x. ï¹«(f, x))) in
        let p' := ps{m, ï¹«(frec, I)} in
        cast(P{S(m)}, P{Sm'}, R(e, x.P{x}), p')))
    in
    let b2 : Tm(El(ï¹«(motive, false))) :=
        Î»(f. Î»(_.
        let 0' : Tm(â„•) := sup(false, f) in
        let e : Tm(Eq(â„•, 0, 0')) :=
            EqW_i(refl, x. âˆ…ind(x)) in
        cast(P{0}, P{0'}, R(e, x. P{x}), p0)))
    in
    Wind(n, x. P{x}, b f frec.
        let M := if(b, x. El(ï¹«(motive, x)), b1, b2) in
        ï¹«(ï¹«(M, f), frec))

let 0â‰¢Sn (n : Tm(â„•), p : Tm(Eq(â„•, 0, S(n)))) : Tm(âˆ…)
    := let câˆ…â‰¡câ‹† := R(p, n. El(â„•ind(n, _. U, c(â‹†), _ _. c(âˆ…)))) in
    cast(â‹† :: Ty, âˆ…, câˆ…â‰¡câ‹†, I)

