(* MLTT with a cumulative hierarchy of Tarski-style universes and universe polymorphism *)

(* variant in which Ï€ is heterogeneous, in the sense that it is allowed to take two codes
   a and b in different universes. this unfortunately leads to more annotations in the syntax. *)

(* Judgment forms *)
sort Ty ()
sort Tm (A : Ty)

sort Lvl ()
constructor 0â‚— () () : Lvl
constructor Sâ‚— () (_ : Lvl) : Lvl
destructor maxâ‚— () [i : Lvl] (j : Lvl) : Lvl

equation maxâ‚—(0â‚—, j) --> j
equation maxâ‚—(Sâ‚—(i), 0â‚—) --> Sâ‚—(i)
equation maxâ‚—(Sâ‚—(i), Sâ‚—(j)) --> Sâ‚—(maxâ‚—(i, j))


(* Taski-style universe *)
constructor U () (l : Lvl) : Ty
destructor El (l : Lvl) [A : Tm(U(l))] () : Ty


(* we must declare the level l as an index, otherwise l is omitted from the
   syntax and we cannot write the rule  El(ğ‘¢) --> U(?) because we don't know
   what to put in the place of ? *)
constructor ğ‘¢ () (l : Lvl) (Sâ‚—(l) / l : Lvl) : Tm(U(l))
equation El(ğ‘¢(l)) --> U(l)


(* we can also declare â†‘ as a destructor if we want *)
constructor â†‘ (i : Lvl) (a : Tm(U(i))) : Tm(U(Sâ‚—(i)))
equation El(â†‘(A)) --> El(A)


(* Dependent products *)
constructor Î    ()
                (A : Ty, B{x : Tm(A)} : Ty)
                : Ty

constructor Î»   (A : Ty, B{x : Tm(A)} : Ty)
                (t{x : Tm(A)} : Tm(B{x}))
                : Tm(Î (A, x. B{x}))

destructor ï¹«   (A : Ty, B{x : Tm(A)} : Ty)
                [t : Tm(Î (A, x. B{x}))]
                (u : Tm(A))
                : Tm(B{u})

equation ï¹«(Î»(x. t{x}), u) --> t{u}

(* in order to allow a and b to live in two different universes, we have to add
   the level annotations to the syntax unfortunately *)
constructor Ï€ () (i1 : Lvl, i2 : Lvl, a : Tm(U(i1)), b{_ : Tm(El(a))} : Tm(U(i2)))
              (maxâ‚—(i1, i2) / i : Lvl) : Tm(U(i))
equation El(Ï€(i1, i2, a, x.b{x})) --> Î (El(a), x. El(b{x}))


(* Natural numbers *)
constructor â„• () () : Ty
constructor 0 () () : Tm(â„•)
constructor S () (_ : Tm(â„•)) : Tm(â„•)

destructor ind_â„•    ()
                    [n : Tm(â„•)]
                    (P {x : Tm(â„•)} : Ty,
                     p0 : Tm(P{0}),
                     ps {n : Tm(â„•), pn : Tm(P{n})} : Tm(P{S(n)}))
                (* ------------ *)
                    : Tm(P{n})

equation ind_â„•(0, x. P{x}, p0, n pn. ps{n, pn}) --> p0
equation ind_â„•(S(n), x. P{x}, p0, n pn. ps{n, pn}) -->
    ps{n, ind_â„•(n, x. P{x}, p0, n pn. ps{n, pn})}

(* code in U for â„• *)
constructor nat (i : Lvl) () : Tm(U(i))
equation El(nat) --> â„•



(* universe polymorphism (quantification over levels) *)
constructor âˆ€ () (A {i : Lvl} : Ty) : Ty
constructor Î› (A {i : Lvl} : Ty) (t{i : Lvl} : Tm(A{i}))
        : Tm(âˆ€(i. A{i}))
destructor inst (A {i : Lvl} : Ty) [t : Tm(âˆ€(i. A{i}))] (l : Lvl)
        : Tm(A{l})
equation inst(Î›(i. t{i}), l) --> t{l}


(* universe polymorphic id function *)
(* note that the sort cannot be simplified, because
   maxâ‚—(Sâ‚—(i), maxâ‚—(i,i)) = Sâ‚—(i) does not hold on open terms *)
let id_poly : Tm(âˆ€(i. El(Ï€(Sâ‚—(i), maxâ‚—(i,i), ğ‘¢(i), a. Ï€(i, i, a, _. a))
                          :: Tm(U(maxâ‚—(Sâ‚—(i) :: Lvl, maxâ‚—(i,i)))))))
  :=  Î›(i. Î»(a. Î»(x. x)))

(* the above sort is convertible to Tm(âˆ€(i. Î (U(i), a. Î (El(a), _. El(a))))) *)
evaluate Tm(âˆ€(i. El(Ï€(Sâ‚—(i), maxâ‚—(i,i), ğ‘¢(i), a. Ï€(i, i, a, _. a))
                          :: Tm(U(maxâ‚—(Sâ‚—(i) :: Lvl, maxâ‚—(i,i)))))))

(* applying it to 0 *)
let 0' : Tm(â„•) := ï¹«(ï¹«(inst(id_poly, 0â‚—), nat), 0)
assert 0' = 0
