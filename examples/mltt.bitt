
(* MLTT with a type-in-type Taski-style universe *)

(* Judgment forms *)
sort Ty ()
sort Tm (A : Ty)


(* Taski-style universe *)
constructor U () () : Ty
destructor El () (A : Tm(U)) () : Ty

(* type in type *)
constructor ð‘¢ () () : Tm(U)
rewrite El(ð‘¢) --> U


(* Dependent products *)
constructor Î    ()
                (A : Ty, B{x : Tm(A)} : Ty) 
                : Ty

constructor Î»   (A : Ty, B{x : Tm(A)} : Ty) 
                (t{x : Tm(A)} : Tm(B{x})) 
                : Tm(Î (A, x. B{x}))

destructor ï¹«   (A : Ty, B{x : Tm(A)} : Ty) 
                (t : Tm(Î (A, x. B{x})))
                (u : Tm(A))
                : Tm(B{u})

rewrite ï¹«(Î»(x. t{x}), u) --> t{u}


constructor Ï€ () (a : Tm(U), b{_ : Tm(El(a))} : Tm(U)) : Tm(U)
rewrite El(Ï€(a, x.b{x})) --> Î (El(a), x. El(b{x}))


(* Dependent sums *)
constructor Î£ () (A : Ty, B{x : Tm(A)} : Ty) : Ty

constructor mkÎ£     (A : Ty, B{x : Tm(A)} : Ty) 
                    (t : Tm(A), u : Tm(B{t}))
                    : Tm(Î£(A, x. B{x}))

destructor Ï€â‚       (A : Ty, B{x : Tm(A)} : Ty) 
                    (t : Tm(Î£(A, x. B{x})))
                    () : Tm(A)

destructor Ï€â‚‚       (A : Ty, B{x : Tm(A)} : Ty) 
                    (t : Tm(Î£(A, x. B{x})))
                    () : Tm(B{Ï€â‚(t)})

rewrite Ï€â‚(mkÎ£(t, u)) --> t
rewrite Ï€â‚‚(mkÎ£(t, u)) --> u


constructor Ïƒ () (a : Tm(U), b{x : Tm(El(a))} : Tm(U)) : Tm(U)
rewrite El(Ïƒ(a, x.b{x})) --> Î£(El(a), x. El(b{x}))


(* axiom of choice *)
let ac : Tm(Î (U, a. Î (U, b. Î (Î (El(b), _. U), c.
            Î (Î (El(a), _. Î£(El(b), x. El(ï¹«(c, x)))), _.
            Î£(Î (El(a), _. El(b)), f. Î (El(a), x. El(ï¹«(c, ï¹«(f, x))))))))))
    := Î»(a. Î»(b. Î»(c. Î»(Ï•. mkÎ£(Î»(x. Ï€â‚(ï¹«(Ï•, x))), Î»(x. Ï€â‚‚(ï¹«(Ï•, x))))))))


(* Natural numbers *)
constructor â„• () () : Ty
constructor 0 () () : Tm(â„•)
constructor S () (_ : Tm(â„•)) : Tm(â„•)

destructor ind_â„•    ()
                    (n : Tm(â„•))
                    (P {x : Tm(â„•)} : Ty, 
                     p0 : Tm(P{0}), 
                     ps {n : Tm(â„•), pn : Tm(P{n})} : Tm(P{S(n)}))
                (* ------------ *)
                    : Tm(P{n})

rewrite ind_â„•(0, x. P{x}, p0, n pn. ps{n, pn}) --> p0
rewrite ind_â„•(S(n), x. P{x}, p0, n pn. ps{n, pn}) -->
    ps{n, ind_â„•(n, x. P{x}, p0, n pn. ps{n, pn})}

(* code in U for â„• *)
constructor nat () () : Tm(U)
rewrite El(nat) --> â„•


(* Some functions written using ind_â„• *)
let ï¼‹ : Tm(Î (â„•, _. Î (â„•, _. â„•))) := Î»(x. Î»(y. ind_â„•(y, _. â„•, x, _ n. S(n))))

let Ã— : Tm(Î (â„•, _. Î (â„•, _. â„•))) :=
    Î»(x. Î»(y. ind_â„•(y, _. â„•, 0, _ n. ï¹«(ï¹«(ï¼‹, n), x))))

let fact : Tm(Î (â„•, _. â„•)) := Î»(x. ind_â„•(x, _. â„•, S(0), n m. ï¹«(ï¹«(Ã—, S(n)), m)))

let fact_4 : Tm(â„•) := ï¹«(fact, S(S(S(S(0)))))
eval fact_4


(* Lists *)
constructor List () (A : Ty) : Ty
constructor nil (A : Ty) () : Tm(List(A))
constructor cons (A : Ty) (a : Tm(A), l : Tm(List(A))) : Tm(List(A))

destructor ind_List     (A : Ty)
                        (l : Tm(List(A)))
                        (P {x : Tm(List(A))} : Ty,
                         l_nil : Tm(P{nil}),
                         l_cons {a : Tm(A), l : Tm(List(A)), pl : Tm(P{l})} : Tm(P{cons(a, l)}))
                        (* -------------- *)
                        : Tm(P{l})

rewrite ind_List(nil, l. P{l}, p_nil, a l pl. p_cons{a, l, pl}) --> p_nil
rewrite ind_List(cons(a, l), l. P{l}, p_nil, a l pl. p_cons{a, l, pl}) -->
    p_cons{a, l, ind_List(l, l. P{l}, p_nil, a l pl. p_cons{a, l, pl})}


(* code in U for List *)
constructor list () (a : Tm(U)) : Tm(U)
rewrite El(list(a)) --> List(El(a))


let 0âˆ·1âˆ·2âˆ·3âˆ·nil : Tm(List(â„•)) := cons(0, cons(S(0), cons(S(S(0)), cons(S(S(S(0))), nil))))

let sum_of_list : Tm(Î (List(â„•), _. â„•)) :=
    Î»(l. ind_List(l, _. â„•, 0, x _ acc. ï¹«(ï¹«(ï¼‹, x), acc)))
eval ï¹«(sum_of_list, 0âˆ·1âˆ·2âˆ·3âˆ·nil)

(* W Types *)
constructor W () (A : Ty, B{x : Tm(A)} : Ty) : Ty 
constructor sup (A : Ty, B{x : Tm(A)} : Ty)
                (a : Tm(A), f : Tm(Î (B{a}, _. W(A, x.B{x}))))
                : Tm(W(A, x.B{x}))

destructor ind_W    (A : Ty, B{x : Tm(A)} : Ty)
                    (t : Tm(W(A, x.B{x})))
                    (P{x : Tm(W(A, x.B{x}))} : Ty,
                     p{x : Tm(A), 
                       y : Tm(Î (B{x}, _. W(A, x.B{x}))), 
                       z : Tm(Î (B{x}, x'. P{ï¹«(y, x')}))} : Tm(P{sup(x, y)}) )
                       : Tm(P{t})

rewrite ind_W(sup(a, f), x. P{x}, x y z. p{x, y, z}) --> 
        p{a, f, Î»(x. ind_W(ï¹«(f, x), x. P{x}, x y z. p{x, y, z}))}

constructor w () (a : Tm(U), b{x : Tm(El(a))} : Tm(U)) : Tm(U)
rewrite El(w(a, x.b{x})) --> W(El(a), x.El(b{x}))

(* auxiliary types to define nat with W *)

constructor âŠ¥ () () : Ty 
destructor ind_âŠ¥ () (x : Tm(âŠ¥)) (P : Ty) : Tm(P)

constructor âŠ¥c () () : Tm(U)
rewrite El(âŠ¥c) --> âŠ¥

constructor âŠ¤ () () : Ty 
constructor I () () : Tm(âŠ¤)

constructor âŠ¤c () () : Tm(U)
rewrite El(âŠ¤c) --> âŠ¤


constructor Bool () () : Ty 
constructor tt () () : Tm(Bool)
constructor ff () () : Tm(Bool)

destructor if () (x : Tm(Bool)) 
                 (P{x : Tm(Bool)} : Ty, 
                  a : Tm(P{tt}), 
                  b : Tm(P{ff})) : Tm(P{x})
rewrite if(tt, x.P{x}, a, b) --> a 
rewrite if(ff, x.P{x}, a, b) --> b

(* different definition of Nat, using W types *)
let Nat : Ty := W(Bool, x. El(if(x, _. U, âŠ¤c, âŠ¥c)))
let zero : Tm(Nat) := sup(ff, Î»(x. ind_âŠ¥(x, Nat)))
let succ : Tm(Î (Nat, _. Nat)) := Î»(x. sup(tt, Î»(_. x)))

let plus : Tm(Î (Nat, _. Î (Nat, _. Nat))) 
  := Î»(x. Î»(y. 
    ind_W(x, _. Nat, b f h. 
     ï¹«(if(b, 
           x. Î (Î (El(if(x, _. U, âŠ¤c, âŠ¥c)), _. Nat), _. Nat), 
           Î»(h. ï¹«(succ, ï¹«(h, I))), 
           Î»(_. y)), 
      h))))

let 2_Nat : Tm(Nat) := ï¹«(succ, ï¹«(succ, zero))
let 3_Nat : Tm(Nat) := ï¹«(succ, 2_Nat)
let 5_Nat : Tm(Nat) := ï¹«(succ, ï¹«(succ, 3_Nat))

check 5_Nat = ï¹«(ï¹«(plus, 2_Nat), 3_Nat)
