
(* MLTT with a type-in-type Taski-style universe *)

(* Judgment forms *)
sort Ty ()
sort Tm (A : Ty)


(* Taski-style universe *)
constructor U () () : Ty
destructor El () (A : Tm(U)) () : Ty

(* type in type *)
constructor 𝑢 () () : Tm(U)
rewrite El(𝑢) --> U


(* Dependent products *)
constructor Π   ()
                (A : Ty, B{x : Tm(A)} : Ty) 
                : Ty

constructor λ   (A : Ty, B{x : Tm(A)} : Ty) 
                (t{x : Tm(A)} : Tm(B{x})) 
                : Tm(Π(A, x. B{x}))

destructor ﹫   (A : Ty, B{x : Tm(A)} : Ty) 
                (t : Tm(Π(A, x. B{x})))
                (u : Tm(A))
                : Tm(B{u})

rewrite ﹫(λ(x. t{x}), u) --> t{u}


constructor π () (a : Tm(U), b{_ : Tm(El(a))} : Tm(U)) : Tm(U)
rewrite El(π(a, x.b{x})) --> Π(El(a), x. El(b{x}))


(* Dependent sums *)
constructor Σ () (A : Ty, B{x : Tm(A)} : Ty) : Ty

constructor mkΣ     (A : Ty, B{x : Tm(A)} : Ty) 
                    (t : Tm(A), u : Tm(B{t}))
                    : Tm(Σ(A, x. B{x}))

destructor π₁       (A : Ty, B{x : Tm(A)} : Ty) 
                    (t : Tm(Σ(A, x. B{x})))
                    () : Tm(A)

destructor π₂       (A : Ty, B{x : Tm(A)} : Ty) 
                    (t : Tm(Σ(A, x. B{x})))
                    () : Tm(B{π₁(t)})

rewrite π₁(mkΣ(t, u)) --> t
rewrite π₂(mkΣ(t, u)) --> u


constructor σ () (a : Tm(U), b{x : Tm(El(a))} : Tm(U)) : Tm(U)
rewrite El(σ(a, x.b{x})) --> Σ(El(a), x. El(b{x}))


(* axiom of choice *)
let ac : Tm(Π(U, a. Π(U, b. Π(Π(El(b), _. U), c.
            Π(Π(El(a), _. Σ(El(b), x. El(﹫(c, x)))), _.
            Σ(Π(El(a), _. El(b)), f. Π(El(a), x. El(﹫(c, ﹫(f, x))))))))))
    := λ(a. λ(b. λ(c. λ(ϕ. mkΣ(λ(x. π₁(﹫(ϕ, x))), λ(x. π₂(﹫(ϕ, x))))))))


(* Natural numbers *)
constructor ℕ () () : Ty
constructor 0 () () : Tm(ℕ)
constructor S () (_ : Tm(ℕ)) : Tm(ℕ)

destructor ind_ℕ    ()
                    (n : Tm(ℕ))
                    (P {x : Tm(ℕ)} : Ty, 
                     p0 : Tm(P{0}), 
                     ps {n : Tm(ℕ), pn : Tm(P{n})} : Tm(P{S(n)}))
                (* ------------ *)
                    : Tm(P{n})

rewrite ind_ℕ(0, x. P{x}, p0, n pn. ps{n, pn}) --> p0
rewrite ind_ℕ(S(n), x. P{x}, p0, n pn. ps{n, pn}) -->
    ps{n, ind_ℕ(n, x. P{x}, p0, n pn. ps{n, pn})}

(* code in U for ℕ *)
constructor nat () () : Tm(U)
rewrite El(nat) --> ℕ


(* Some functions written using ind_ℕ *)
let ＋ : Tm(Π(ℕ, _. Π(ℕ, _. ℕ))) := λ(x. λ(y. ind_ℕ(y, _. ℕ, x, _ n. S(n))))

let × : Tm(Π(ℕ, _. Π(ℕ, _. ℕ))) :=
    λ(x. λ(y. ind_ℕ(y, _. ℕ, 0, _ n. ﹫(﹫(＋, n), x))))

let fact : Tm(Π(ℕ, _. ℕ)) := λ(x. ind_ℕ(x, _. ℕ, S(0), n m. ﹫(﹫(×, S(n)), m)))

let fact_4 : Tm(ℕ) := ﹫(fact, S(S(S(S(0)))))
eval fact_4


(* Lists *)
constructor List () (A : Ty) : Ty
constructor nil (A : Ty) () : Tm(List(A))
constructor cons (A : Ty) (a : Tm(A), l : Tm(List(A))) : Tm(List(A))

destructor ind_List     (A : Ty)
                        (l : Tm(List(A)))
                        (P {x : Tm(List(A))} : Ty,
                         l_nil : Tm(P{nil}),
                         l_cons {a : Tm(A), l : Tm(List(A)), pl : Tm(P{l})} : Tm(P{cons(a, l)}))
                        (* -------------- *)
                        : Tm(P{l})

rewrite ind_List(nil, l. P{l}, p_nil, a l pl. p_cons{a, l, pl}) --> p_nil
rewrite ind_List(cons(a, l), l. P{l}, p_nil, a l pl. p_cons{a, l, pl}) -->
    p_cons{a, l, ind_List(l, l. P{l}, p_nil, a l pl. p_cons{a, l, pl})}


(* code in U for List *)
constructor list () (a : Tm(U)) : Tm(U)
rewrite El(list(a)) --> List(El(a))


let 0∷1∷2∷3∷nil : Tm(List(ℕ)) := cons(0, cons(S(0), cons(S(S(0)), cons(S(S(S(0))), nil))))

let sum_of_list : Tm(Π(List(ℕ), _. ℕ)) :=
    λ(l. ind_List(l, _. ℕ, 0, x _ acc. ﹫(﹫(＋, x), acc)))
eval ﹫(sum_of_list, 0∷1∷2∷3∷nil)

(* W Types *)
constructor W () (A : Ty, B{x : Tm(A)} : Ty) : Ty 
constructor sup (A : Ty, B{x : Tm(A)} : Ty)
                (a : Tm(A), f : Tm(Π(B{a}, _. W(A, x.B{x}))))
                : Tm(W(A, x.B{x}))

destructor ind_W    (A : Ty, B{x : Tm(A)} : Ty)
                    (t : Tm(W(A, x.B{x})))
                    (P{x : Tm(W(A, x.B{x}))} : Ty,
                     p{x : Tm(A), 
                       y : Tm(Π(B{x}, _. W(A, x.B{x}))), 
                       z : Tm(Π(B{x}, x'. P{﹫(y, x')}))} : Tm(P{sup(x, y)}) )
                       : Tm(P{t})

rewrite ind_W(sup(a, f), x. P{x}, x y z. p{x, y, z}) --> 
        p{a, f, λ(x. ind_W(﹫(f, x), x. P{x}, x y z. p{x, y, z}))}

constructor w () (a : Tm(U), b{x : Tm(El(a))} : Tm(U)) : Tm(U)
rewrite El(w(a, x.b{x})) --> W(El(a), x.El(b{x}))

(* auxiliary types to define nat with W *)

constructor ⊥ () () : Ty 
destructor ind_⊥ () (x : Tm(⊥)) (P : Ty) : Tm(P)

constructor ⊥c () () : Tm(U)
rewrite El(⊥c) --> ⊥

constructor ⊤ () () : Ty 
constructor I () () : Tm(⊤)

constructor ⊤c () () : Tm(U)
rewrite El(⊤c) --> ⊤


constructor Bool () () : Ty 
constructor tt () () : Tm(Bool)
constructor ff () () : Tm(Bool)

destructor if () (x : Tm(Bool)) 
                 (P{x : Tm(Bool)} : Ty, 
                  a : Tm(P{tt}), 
                  b : Tm(P{ff})) : Tm(P{x})
rewrite if(tt, x.P{x}, a, b) --> a 
rewrite if(ff, x.P{x}, a, b) --> b

(* different definition of Nat, using W types *)
let Nat : Ty := W(Bool, x. El(if(x, _. U, ⊤c, ⊥c)))
let zero : Tm(Nat) := sup(ff, λ(x. ind_⊥(x, Nat)))
let succ : Tm(Π(Nat, _. Nat)) := λ(x. sup(tt, λ(_. x)))

let plus : Tm(Π(Nat, _. Π(Nat, _. Nat))) 
  := λ(x. λ(y. 
    ind_W(x, _. Nat, b f h. 
     ﹫(if(b, 
           x. Π(Π(El(if(x, _. U, ⊤c, ⊥c)), _. Nat), _. Nat), 
           λ(h. ﹫(succ, ﹫(h, I))), 
           λ(_. y)), 
      h))))

let 2_Nat : Tm(Nat) := ﹫(succ, ﹫(succ, zero))
let 3_Nat : Tm(Nat) := ﹫(succ, 2_Nat)
let 5_Nat : Tm(Nat) := ﹫(succ, ﹫(succ, 3_Nat))

check 5_Nat = ﹫(﹫(plus, 2_Nat), 3_Nat)
