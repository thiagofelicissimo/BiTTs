(* yet another version of MLTT with cumulative Russell-style universes, and universe polymorphism.
   this is similar to a version from Jon Sterling's thesis, Figure 1.2, and has the advantage
   over "mltt-russell.bitts" of allowing for a lift that commutes with type formers. *)

sort Ty ()
sort Tm (A : Ty)

sort Lvl ()
constructor 0â‚— () () : Lvl
constructor Sâ‚— () (_ : Lvl) : Lvl

sort ty (i : Lvl)
sort tm (i : Lvl, a : ty(i))

(* we define tm(i, a) as meaning Tm(â‡‘(i, a)) *)
constructor â‡‘ () (i : Lvl, A : ty(i)) : Ty
equation tm(i, a) --> Tm(â‡‘(i, a))

constructor U () (i : Lvl) : Ty
equation Tm(U(i)) --> ty(i)


constructor â†‘ (l : Lvl) (A : ty(l)) : ty(Sâ‚—(l))
equation â‡‘(Sâ‚—(i), â†‘(a)) --> â‡‘(i, a)

constructor ğ‘¢ (i : Lvl) () : ty(Sâ‚—(i))
equation â‡‘(Sâ‚—(i), ğ‘¢) --> U(i)


(* Dependent products *)
constructor Î  () (A : Ty, B {x : Tm(A)} : Ty) : Ty
constructor Î» (A : Ty, B {x : Tm(A)} : Ty) (t{x : Tm(A)} : Tm(B{x}))
        : Tm(Î (A, x. B{x}))
destructor ï¹« (A : Ty, B {x : Tm(A)} : Ty) [t : Tm(Î (A, x. B{x}))] (u : Tm(A))
        : Tm(B{u})
equation ï¹«(Î»(x. t{x}), u) --> t{u}

constructor Ï€ (i : Lvl) (a : ty(i), b{x : Tm(â‡‘(i, a))} : ty(i)) : ty(i)
equation â‡‘(i, Ï€(A, x. B{x})) --> Î (â‡‘(i, A), x. â‡‘(i, B{x}))

(* this rule creates a critical pair with rule 3.
   however, the critical pair can be joined, and the rules are terminating
   without beta, and thus confluent. then, we conclude the confluence with beta
   because beta is confluent by orthogonality and does not create a critical pair
   with the rest of the rewrite system *)
equation â†‘(Ï€(A, x. B{x})) --> Ï€(â†‘(A), x. â†‘(B{x}))


(* Natural numbers *)
constructor â„• () () : Ty
constructor 0 () () : Tm(â„•)
constructor S () (n : Tm(â„•)) : Tm(â„•)

destructor â„•_ind    ()
                    [n : Tm(â„•)]
                    (P {x : Tm(â„•)} : Ty,
                     p0 : Tm(P{0}),
                     ps {n : Tm(â„•), pn : Tm(P{n})} : Tm(P{S(n)}))
                (* ------------ *)
                    : Tm(P{n})

equation â„•_ind(0, x. P{x}, p0, n pn. ps{n, pn}) --> p0
equation â„•_ind(S(n), x. P{x}, p0, n pn. ps{n, pn}) -->
    ps{n, â„•_ind(n, x. P{x}, p0, n pn. ps{n, pn})}


constructor nat (i : Lvl) () : ty(i)
equation â‡‘(i, nat) --> â„•

(* same remark as for the rule envolving â†‘ and Ï€ *)
equation â†‘(nat) --> nat

(* universe polymorphism (quantification over levels) *)
constructor âˆ€ () (A {i : Lvl} : Ty) : Ty
constructor Î› (A {i : Lvl} : Ty) (t{i : Lvl} : Tm(A{i}))
        : Tm(âˆ€(i. A{i}))
destructor inst (A {i : Lvl} : Ty) [t : Tm(âˆ€(i. A{i}))] (l : Lvl)
        : Tm(A{l})
equation inst(Î›(i. t{i}), l) --> t{l}


(* universe polymorphic id function *)
let id_poly : Tm(âˆ€(i. â‡‘(Sâ‚—(i), Ï€(ğ‘¢, A. Ï€(â†‘(A), _. â†‘(A))))))
    :=  Î›(i. Î»(a. Î»(x. x)))

(* applying it to 0 *)
let 0' : tm(0â‚—, nat) := ï¹«(ï¹«(inst(id_poly, 0â‚—), nat), 0)
assert 0' = 0
